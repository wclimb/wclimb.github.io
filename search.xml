<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库（一）]]></title>
    <url>%2F2017%2F06%2F29%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面 读zepto源码，封装自己的zepto库系列是自己在读zepto源码的一些理解，有错误的地方还望指出。如果觉得本系列对你有所帮助，还请持续关注wclimb，谢谢。 zepto的整体架构首先来看看整体代码结构 123456789101112131415161718192021222324252627282930313233(function()&#123; var wclimb = &#123;&#125;,$ $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; wclimb.Z.prototype = Z.prototype = &#123; test:function()&#123; alert(1) &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wclimb = $&#125;)() 首先我们设置了一个闭包，避免产生全局变量123(function()&#123; ...&#125;)() 我们定义一个对象wclimb和$，以便后面使用 1var wclimb = &#123;&#125;,$ $函数返回了wclimb.init(selector),我们知道使用zepto的时候，一般是$(‘p’)，而selector就是p元素，当然不止这一种情况如$(function(){}),所以对选择器后面我们要做判断123$ = function(selector)&#123; return wclimb.init(selector)&#125; 而wclimb.init首先定义了一个dom，通过选择器选取的元素赋值给dom，最后返回wclimb.init，传入dom和选择元素selector 12345wclimb.init = function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector)&#125; 我们可以看到之前我们定义了对象wclimb，而后我们就往里面添加了一些方法，就像： 12345678910wclimb = &#123; init：function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector) &#125;, Z: function(dom,selector)&#123; return new Z(dom,selector) &#125;&#125; 通过wclimb.Z，如果有看过zepto源码的同学应该对此有了解.每次用$调用的时候,将直接返回一个Z的实例.达到无new调用的效果,$(‘p’)返回一个实例，然后$(‘p’).test()调用他的原形方法，这里的方法是test 1234567891011wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector)&#125;function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 由于我们是return new Z(dom,selector),那自然,我们需要手动的把wclimb.Z的prototype指向Z的prototype 123456789wclimb.Z.prototype = Z.prototype&#123;&#125;我们可以在里面添加方法了，如addClass eq等，我们试试加一个testwclimb.Z.prototype = Z.prototype&#123; test: function()&#123; console.log(&apos;test&apos;) &#125;&#125; Z函数是这样的，因为我们选择器选择的元素是一个数组（其实不是）我们把this指向选择的元素，然后添加两个元素selector和length，分别代表选择的元素名和元素的长度 1234567function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 最后我们在window上对外暴露一个接口,我们就可以用 $(‘p’) 或者wclimb(‘p’) 即可调用. 1window.$ = window.wclimb = $ 现在可以试试能不能运行 123html：&lt;p&gt;test&lt;/p&gt;js：$(&apos;p&apos;) 调用方法试试 $(&apos;p&apos;).test() 我们的zepto已经完成了，是不是很简单？骗你的，还差得远呢，后面会慢慢完善。待续。。。如果你觉得该文章帮助到了你，不妨star一下https://github.com/wclimb/wclimb.github.io ，感谢]]></content>
      <tags>
        <tag>zepto</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2017%2F06%2F28%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas仿微信红包 By wclimbHTML1&lt;canvas id=&quot;cav&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt; CSS 设置canvas的背景图 1234canvas&#123; background:url(https://b-ssl.duitang.com/uploads/item/201501/22/20150122203239_Cfr58.thumb.700_0.jpeg) no-repeat; background-size:100% 100%;&#125; JS12345678910111213141516171819202122232425262728293031323334353637var canvas = document.querySelector(&quot;#cav&quot;)var context = canvas.getContext(&quot;2d&quot;);var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30)context.globalAlpha = 0.96;context.fillStyle = &apos;#333&apos;context.rect(0,0,canvas.width,canvas.height);context.fill();context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore();var num = 30;var time = null;document.body.onclick = function()&#123; function circle()&#123; num += 5 context.save() context.beginPath() context.arc(randomX,randomY,num,0,Math.PI*2,false); context.clip(); context.clearRect(0,0,canvas.width,canvas.height) context.restore(); console.log(num) if (num &gt;= 677)&#123; clearInterval(timer) &#125; &#125; timer = setInterval(circle,10)&#125; 解析 随机出现圆心的位置，因为canvas为500*500 圆心为30 所以圆心的范围为 X(30,470) Y(470,30) 12var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30) 绘制矩形 透明度为0.96 填充颜色#333 宽高为canvas的宽高 最后用fill填充 1234context.globalAlpha = 0.96;context.fillStyle = &apos;#333&apos;context.rect(0,0,canvas.width,canvas.height);context.fill(); 初始化圆心的位置，用arc绘制圆，默认半径为30，用clip剪切，只有被剪切区域内是可见的 123456context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore(); 点击body的时候，设置定时器，让圆的半径每隔10毫秒增加5，当num半径大于677关闭定时器，677为canvas对角的长度 1document.body.onclick = function()&#123;&#125; 效果预览]]></content>
      <categories>
        <category>javascript</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp基础教程]]></title>
    <url>%2F2017%2F06%2F27%2Fgulp%2F</url>
    <content type="text"><![CDATA[入门指南–引用gulp官网示例 全局安装 gulp： 1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： 1$ npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 12345var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp： 1$ gulp //默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。 至此，一个简单的gulp已经完成，接下来让我们来完善部分功能 gulp功能完善生成package.json文件1$ npm init //一直回车，有需要的可以设置 安装所需包 使用淘宝镜像 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org示例 $ cnpm install [name] 接着1$ cnpm i browser-sync gulp gulp-clean-css gulp-imagemin gulp-rename gulp-sass gulp-uglify gulp.spritesmith gulp-autoprefixer --save 新建gulpfile.js文件添加123456789var gulp = require(&apos;gulp&apos;); var browserSync = require(&apos;browser-sync&apos;).create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require(&apos;gulp-sass&apos;); //sass转cssvar reload = browserSync.reload; var minifyCSS = require(&apos;gulp-clean-css&apos;) //css压缩var uglify = require(&apos;gulp-uglify&apos;) //js压缩var imagemin = require(&apos;gulp-imagemin&apos;) //图片压缩var rename = require(&apos;gulp-rename&apos;) //文件重命名var autoprefixer = require(&apos;gulp-autoprefixer&apos;) //自动添加前缀 设置默认文件地址12345678code为文件夹，里面存放html css js文件var src = &#123; scss: &apos;code/scss/*.scss&apos;, css: &apos;code/css/*.css&apos;, html: &apos;code/*.html&apos;, js: &apos;code/js/*.js&apos;, images: &apos;code/images/*.&#123;png,jpg,gif,ico&#125;&apos;&#125;; gulp.task(name[, deps], fn)123456789101112131415161718name: 任务的名字deps: 一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。fn: 该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。// 静态服务器 + 监听 scss/html 文件 gulp.task(&apos;serve&apos;, [&apos;sass&apos;], function() &#123; browserSync.init(&#123; server: &quot;./code&quot; &#125;); gulp.watch(src.scss, [&apos;sass&apos;]); gulp.watch(src.css, [&apos;css&apos;]); gulp.watch(src.images, [&apos;images&apos;]) gulp.watch(src.js, [&apos;js-watch&apos;]); gulp.watch(src.js, [&apos;js&apos;]); gulp.watch(src.html).on(&apos;change&apos;, reload);&#125;); scss编译后的css将注入到浏览器里实现更新123456789101112131415gulp.task(&apos;sass&apos;, function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;,//保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 雪碧图（有需要可以尝试）123456789101112var spritesmith = require(&apos;gulp.spritesmith&apos;); gulp.task(&apos;sprite&apos;, function () &#123; return gulp.src(&apos;code/images/*.png&apos;) .pipe(spritesmith(&#123; imgName:&apos;images/sprite20161010.png&apos;, //保存合并后图片的地址 cssName:&apos;css/sprite.css&apos;, //保存合并后对于css样式的地址 padding:20, algorithm:&apos;binary-tree&apos;, &#125;)) .pipe(gulp.dest(&apos;code/scss&apos;)); &#125;); 监听css文件1234567gulp.task(&apos;css&apos;, function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 监听js文件12345678910111213gulp.task(&apos;js&apos;, function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest(&apos;code/dest&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;)//监听js文件变化实现热加载gulp.task(&apos;js-watch&apos;, [&apos;js&apos;], browserSync.reload); 压缩图片任务12345678910// 在命令行输入 gulp images 启动此任务gulp.task(&apos;images&apos;, function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest(&apos;images&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 最后控制台输入gulp执行1gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 如果觉得帮助到了你，欢迎star -&gt; https://github.com/wclimb/wclimb.github.io 完整代码文件目录123456789101112-code -imgage 1.png -css default.css -scss default.scss -js default.js index.htmlgulpfile.jspackage.json packjson.js12345678910111213141516171819202122232425&#123; &quot;name&quot;: &quot;gulp-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Gulp &amp; SASS&quot;, &quot;main&quot;: &quot;gulpfile.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;gulp&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;browser-sync&quot;: &quot;^2.2.0&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-clean-css&quot;: &quot;^3.0.3&quot;, &quot;gulp-imagemin&quot;: &quot;^3.1.1&quot;, &quot;gulp-rename&quot;: &quot;^1.2.2&quot;, &quot;gulp-sass&quot;: &quot;^3.1.0&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.1&quot;, &quot;gulp.spritesmith&quot;: &quot;^6.4.0&quot;, &quot;gulp-autoprefixer&quot;: &quot;^4.0.0&quot; &#125;, &quot;dependencies&quot;: &#123; &#125;&#125; gulpfile.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106var gulp = require(&apos;gulp&apos;); var browserSync = require(&apos;browser-sync&apos;).create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require(&apos;gulp-sass&apos;); //sass转cssvar reload = browserSync.reload; var minifyCSS = require(&apos;gulp-clean-css&apos;) //css压缩var uglify = require(&apos;gulp-uglify&apos;) //js压缩var imagemin = require(&apos;gulp-imagemin&apos;) //图片压缩var rename = require(&apos;gulp-rename&apos;) //文件重命名var autoprefixer = require(&apos;gulp-autoprefixer&apos;) //自动添加前缀var src = &#123; scss: &apos;code/scss/*.scss&apos;, css: &apos;code/css/*.css&apos;, html: &apos;code/*.html&apos;, js: &apos;code/js/*.js&apos;, images: &apos;code/images/*.&#123;png,jpg,gif,ico&#125;&apos;&#125;;// 静态服务器 + 监听 scss/html 文件 gulp.task(&apos;serve&apos;, [&apos;sass&apos;], function() &#123; browserSync.init(&#123; server: &quot;./code&quot; &#125;); gulp.watch(src.scss, [&apos;sass&apos;]); gulp.watch(src.css, [&apos;css&apos;]); gulp.watch(src.images, [&apos;images&apos;]) gulp.watch(src.js, [&apos;js-watch&apos;]); gulp.watch(src.js, [&apos;js&apos;]); gulp.watch(src.html).on(&apos;change&apos;, reload);&#125;);// scss编译后的css将注入到浏览器里实现更新gulp.task(&apos;sass&apos;, function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;,//保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) //重新输出数据到某个文件夹，如果没有就会自动创建 .pipe(reload(&#123;stream: true&#125;));&#125;);// 雪碧图（有需要可以尝试）//var spritesmith = require(&apos;gulp.spritesmith&apos;); // gulp.task(&apos;sprite&apos;, function () &#123;// return gulp.src(&apos;code/images/*.png&apos;)// .pipe(spritesmith(&#123;// imgName:&apos;images/sprite20161010.png&apos;, //保存合并后图片的地址// cssName:&apos;css/sprite.css&apos;, //保存合并后对于css样式的地址// padding:20,// algorithm:&apos;binary-tree&apos;,// &#125;))// .pipe(gulp.dest(&apos;code/scss&apos;));// &#125;);gulp.task(&apos;css&apos;, function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task(&apos;js&apos;, function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest(&apos;code/dest&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;)//监听js文件变化实现热加载gulp.task(&apos;js-watch&apos;, [&apos;js&apos;], browserSync.reload);// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task(&apos;images&apos;, function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest(&apos;images&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]);]]></content>
      <categories>
        <category>javascript</category>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
</search>