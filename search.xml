<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Node+Koa2+Mysql 搭建简易博客]]></title>
    <url>%2F2017%2F07%2F12%2FNode-Koa2-Mysql-%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Koa2-blogNode+Koa2+Mysql 搭建简易博客 开发环境 nodejs v8.1.0 koa v2.3.0 mysql v5.7.0 准备工作如果你已经配置好node和mysql可以跳过 1$ node -v 查看你的node版本，如果过低则去nodejs官网下载替换之前的版本 下载mysql，并设置好用户名和密码，默认可以为用户名：root，密码：123456 1进入到`bin`目录下 比如 cd C:\Program Files\MySQL\MySQL Server 5.7\bin 然后开启mysql1$ mysql -u root -p 输入密码之后创建database(数据库)，nodesql是我们创建的数据库1$ create database nodesql; 记住sql语句后面一定要跟;符号，接下来看看我们创建好的数据库列表 1$ show databases; 启用创建的数据库1$ use nodesql; 查看数据库中的表 1$ show tables; 显示Empty set (0.00 sec)，因为我们还没有建表，稍后会用代码建表注释：这是后面建表之后的状态 目录结构 config 存放默认文件 lib 存放操作数据库文件 middlewares 存放判断登录与否文件 public 存放样式文件 routes 存放路由文件 views 存放模板文件 index 程序主文件 package.json 包括项目名、作者、依赖等等 首先我们创建koa2-blog文件夹，然后cd koa2-blog1接着使用 `npm init` 来创建package.json 接着安装包，安装之前我们使用cnpm安装1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 1$ cnpm i koa koa-bodyparser koa-mysql-session koa-router koa-session-minimal koa-static koa-views md5 moment mysql --save 各模块用处 koa node框架 koa-bodyparser 表单解析中间件 koa-mysql-session、koa-session-minimal 处理数据库的中间件 koa-router 路由中间件 koa-static 静态资源加载中间件 koa-views 模板引擎 md5 密码加密 moment 时间中间件 mysql 数据库 在文件夹里面新建所需文件 首先配置config我们新建default.js文件 123456789101112131415const config = &#123; // 启动端口 port: 3000, // 数据库配置 database: &#123; DATABASE: &apos;nodesql&apos;, USERNAME: &apos;root&apos;, PASSWORD: &apos;123456&apos;, PORT: &apos;3306&apos;, HOST: &apos;localhost&apos; &#125;&#125;module.exports = config 这是我们所需的一些字段，包括端口和数据库连接所需，最后我们把它exports暴露出去，以便可以在别的地方使用 配置index.js文件index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Koa=require(&apos;koa&apos;);var path=require(&apos;path&apos;)var bodyParser = require(&apos;koa-bodyparser&apos;);var ejs=require(&apos;ejs&apos;);var session = require(&apos;koa-session-minimal&apos;);var MysqlStore = require(&apos;koa-mysql-session&apos;);var config = require(&apos;./config/default.js&apos;);var router=require(&apos;koa-router&apos;)var views = require(&apos;koa-views&apos;)var koaStatic = require(&apos;koa-static&apos;)var app=new Koa()// session存储配置const sessionMysqlConfig= &#123; user: config.database.USERNAME, password: config.database.PASSWORD, database: config.database.DATABASE, host: config.database.HOST,&#125;// 配置session中间件app.use(session(&#123; key: &apos;USER_SID&apos;, store: new MysqlStore(sessionMysqlConfig)&#125;))// 配置静态资源加载中间件app.use(koaStatic( path.join(__dirname , &apos;./public&apos;)))// 配置服务端模板渲染引擎中间件app.use(views(path.join(__dirname, &apos;./views&apos;), &#123; extension: &apos;ejs&apos;&#125;))// 使用表单解析中间件app.use(bodyParser())// 使用新建的路由文件// app.use(require(&apos;./routers/signin.js&apos;).routes())app.use(require(&apos;./routers/signup.js&apos;).routes())// app.use(require(&apos;./routers/posts.js&apos;).routes())// app.use(require(&apos;./routers/signout.js&apos;).routes())// 监听在3000端口app.listen(3000)console.log(`listening on port $&#123;config.port&#125;`) 之前我们配置了default.js，我们就可以在这里使用了首先引入进来 var config = require(‘./config/default.js’);然后在数据库的操作的时候，如config.database.USERNAME，得到的就是root 配置lib的mysql.js文件关于数据库的使用这里介绍一下，首先我们建立了数据库的连接池，以便后面的操作都可以使用到，我们创建了一个函数query，通过返回promise的方式以便可以方便用.then()来获取数据库返回的数据，然后我们定义了三个表的字段，通过createTable来创建我们后面所需的三个表，包括posts(存储文章)，users(存储用户)，comment(存储评论)，create table if not exists users()表示如果users表不存在则创建该表，避免每次重复建表报错的情况。后面我们定义了一系列的方法，最后把他们exports暴露出去。 这里只介绍注册用户insertData，后续的可以自行查看，都差不多 12345// 注册用户let insertData = function( value ) &#123; let _sql = &quot;insert into users(name,pass) values(?,?);&quot; return query( _sql, value )&#125; 我们写了一个_sql的sql语句，意思是插入到users的表中（在这之前我们已经建立了users表）然后要插入的数据分别是name和pass，就是用户名和密码，后面values(?,?)意思很简单，你有几个值就写几个问号，最后调用query函数把sql语句传进去 lib/mysql.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184var mysql = require(&apos;mysql&apos;);var config = require(&apos;../config/default.js&apos;)var pool = mysql.createPool(&#123; host : config.database.HOST, user : config.database.USERNAME, password : config.database.PASSWORD, database : config.database.DATABASE&#125;);let query = function( sql, values ) &#123; return new Promise(( resolve, reject ) =&gt; &#123; pool.getConnection(function(err, connection) &#123; if (err) &#123; resolve( err ) &#125; else &#123; connection.query(sql, values, ( err, rows) =&gt; &#123; if ( err ) &#123; reject( err ) &#125; else &#123; resolve( rows ) &#125; connection.release() &#125;) &#125; &#125;) &#125;)&#125; users= `create table if not exists users( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, pass VARCHAR(40) NOT NULL, PRIMARY KEY ( id ) );` posts= `create table if not exists posts( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, title VARCHAR(40) NOT NULL, content VARCHAR(40) NOT NULL, uid VARCHAR(40) NOT NULL, moment VARCHAR(40) NOT NULL, comments VARCHAR(40) NOT NULL DEFAULT &apos;0&apos;, pv VARCHAR(40) NOT NULL DEFAULT &apos;0&apos;, PRIMARY KEY ( id ) );` comment= `create table if not exists comment( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, content VARCHAR(40) NOT NULL, postid VARCHAR(40) NOT NULL, PRIMARY KEY ( id ) );`let createTable = function( sql ) &#123; return query( sql, [] )&#125;// 建表createTable(users)createTable(posts)createTable(comment)// 注册用户let insertData = function( value ) &#123; let _sql = &quot;insert into users(name,pass) values(?,?);&quot; return query( _sql, value )&#125;// 发表文章let insertPost = function( value ) &#123; let _sql = &quot;insert into posts(name,title,content,uid,moment) values(?,?,?,?,?);&quot; return query( _sql, value )&#125;// 更新文章评论数let updatePostComment = function( value ) &#123; let _sql = &quot;update posts set comments=? where id=?&quot; return query( _sql, value )&#125;// 更新浏览数let updatePostPv = function( value ) &#123; let _sql = &quot;update posts set pv=? where id=?&quot; return query( _sql, value )&#125;// 发表评论let insertComment = function( value ) &#123; let _sql = &quot;insert into comment(name,content,postid) values(?,?,?);&quot; return query( _sql, value )&#125;// 通过名字查找用户let findDataByName = function ( name ) &#123; let _sql = ` SELECT * from users where name=&quot;$&#123;name&#125;&quot; ` return query( _sql)&#125;// 通过文章的名字查找用户let findDataByUser = function ( name ) &#123; let _sql = ` SELECT * from posts where name=&quot;$&#123;name&#125;&quot; ` return query( _sql)&#125;// 通过文章id查找let findDataById = function ( id ) &#123; let _sql = ` SELECT * from posts where id=&quot;$&#123;id&#125;&quot; ` return query( _sql)&#125;// 通过评论id查找let findCommentById = function ( id ) &#123; let _sql = ` SELECT * FROM comment where postid=&quot;$&#123;id&#125;&quot; ` return query( _sql)&#125;// 查询所有文章let findAllPost = function ( ) &#123; let _sql = ` SELECT * FROM posts ` return query( _sql)&#125;// 更新修改文章let updatePost = function(values)&#123; let _sql=`update posts set title=?,content=? where id=?` return query(_sql,values)&#125;// 删除文章let deletePost = function(id)&#123; let _sql=`delete from posts where id = $&#123;id&#125;` return query(_sql)&#125;// 删除评论let deleteComment = function(id)&#123; let _sql=`delete from comment where id = $&#123;id&#125;` return query(_sql)&#125;// 删除所有评论let deleteAllPostComment = function(id)&#123; let _sql=`delete from comment where postid = $&#123;id&#125;` return query(_sql)&#125;// 查找let findCommentLength = function(id)&#123; let _sql=`select content from comment where postid in (select id from posts where id=$&#123;id&#125;)` return query(_sql)&#125;module.exports=&#123; query, createTable, insertData, findDataByName, insertPost, findAllPost, findDataByUser, findDataById, insertComment, findCommentById, updatePost, deletePost, deleteComment, findCommentLength, updatePostComment, deleteAllPostComment, updatePostPv&#125; 现在感觉有点枯燥，那我们先来实现一下注册吧 实现注册页面routers/singup.js 1234567891011var router=require(&apos;koa-router&apos;)();// GET &apos;/signup&apos; 注册页router.get(&apos;/signup&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signup&apos;,&#123; &#125;)&#125;)module.exports=router 使用get方式得到’/signup’页面，然后渲染signup模板，这里我们还没有在写signup.ejs views/signup.ejs 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input class=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input class=&quot;repeatpass&quot; type=&quot;password&quot; name=&quot;repeatpass&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 我们先安装supervisor 1$ cnpm i supervisor supervisor的作用是会监听文件的变化，而我们修改文件之后不必去重启程序1supervisor --harmony index 现在访问 localhost:3000/signup 看看效果吧。注意数据库一定要是开启的状态，不能关闭 完善注册功能首先我们来完善一下样式吧，稍微美化一下 public/index.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181body,header,ul,li,p,div,html,span,h3,a&#123; margin: 0; padding: 0; color: #333;&#125;body&#123; margin-bottom: 20px;&#125;a&#123; text-decoration: none;&#125;header&#123; width: 60%; margin: 20px auto; display: -webkit-flex; display: -moz-flex; display: -ms-flex; display: -o-flex; display: flex; justify-content: space-between;&#125;.user_name&#123; font-size: 20px;&#125;.has_user&#123; &#125;.has_user a,.has_user span,.none_user a&#123; padding: 5px 15px; background: #5FB878; border-radius: 15px; color: #fff; cursor: pointer;&#125;.posts&#123; list-style: none; width: 60%; margin: 0 auto;&#125;.posts li&#123; margin-top: 10px; border: 1px solid #ccc; border-radius: 5px; /*padding: 10px 20px;*/ position: relative; padding-bottom: 50px;&#125;h3&#123; display: inline-block; padding: 5px 10px; background: #1E9FFF; color: #fff; border-radius: 10px;&#125;.post_title p,.post_content p&#123; margin: 10px 0; background: #eee; padding: 10px 20px; border: 1px solid #ddd; border-radius: 4px;&#125;.post_time&#123; position: absolute; bottom: 5px; right: 10px;&#125;.post_3&#123; position: absolute; bottom: 5px; left: 10px;&#125;.post_3 p&#123; display: inline-block; margin-left: 5px;&#125;.post_title&#123; padding: 10px 20px;&#125;.post_content&#123; padding: 0 20px; &#125;.spost&#123; width: 60%; margin:0 auto; border: 1px solid #ddd; position: relative; padding-bottom: 40px;&#125;.spost_user&#123; position: absolute; left: 20px; bottom: 5px;&#125;.edit&#123; position: absolute; right: 20px; bottom: 5px;&#125;.edit p&#123; display: inline-block; margin-left: 10px; &#125;.comment_wrap&#123; width: 60%; margin:20px auto; &#125;.submit&#123; display: block; width: 90px; height: 35px; line-height: 35px; text-align: center; border-radius: 10px; background: #5FB878; cursor: pointer; color: #fff; float: right; margin-top: 20px;&#125;.cmt_content&#123; background: #eee; padding: 20px ; position: relative;&#125;.cmt_name&#123; position: absolute; right: 20px; bottom: 5px;&#125;.cmt_name a&#123; margin-left: 10px;&#125;.cmt_content&#123; margin-top: 10px;&#125;.form&#123; margin:0 auto; width: 50%; margin-top: 20px;&#125;textarea&#123; width: 100%; height: 200px; padding-left: 20px; font-size: 20px;&#125;.container&#123; width: 60%; margin: 0 auto;&#125;input&#123; display: block; width: 100%; height: 40px; padding-left: 20px; font-size: 20px;&#125;.create label&#123; display: block; margin: 10px 0;&#125;.comment_wrap form&#123; width: 100%;&#125;.delete_comment,.delete_post&#123; cursor: pointer;&#125;.delete_comment:hover,.delete_post:hover&#123; color: #f60;&#125;a:hover&#123; color: #f60;&#125; 我们再把模板引擎的header和footer独立出来 /views/header.ejs顺便引入index.css和jq123456789&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;body&gt; /views/footer.ejs 123&lt;/body&gt;&lt;/html&gt; 修改views/signup.ejs 12345678910111213141516171819202122&lt;% include header %&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input class=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input class=&quot;repeatpass&quot; type=&quot;password&quot; name=&quot;repeatpass&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;% include footer %&gt; 修改routers/signup.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var router=require(&apos;koa-router&apos;)();var userModel=require(&apos;../lib/mysql.js&apos;);var md5=require(&apos;md5&apos;)router.get(&apos;/signup&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signup&apos;,&#123; session:ctx.session, &#125;)&#125;)// POST &apos;/signup&apos; 注册页router.post(&apos;/signup&apos;,async (ctx,next)=&gt;&#123; console.log(ctx.request.body) var user=&#123; name:ctx.request.body.name, pass:ctx.request.body.password, repeatpass:ctx.request.body.repeatpass &#125; await userModel.findDataByName(user.name) .then(result=&gt;&#123; // var res=JSON.parse(JSON.stringify(reslut)) console.log(result) if (result.length)&#123; try &#123; throw Error(&apos;用户存在&apos;) &#125;catch (error)&#123; //处理err console.log(error) &#125; ctx.body=&#123; data:1 &#125;;; &#125;else if (user.pass!==user.repeatpass || user.pass==&apos;&apos;)&#123; ctx.body=&#123; data:2 &#125;; &#125;else&#123; ctx.body=&#123; data:3 &#125;; console.log(&apos;注册成功&apos;) // ctx.session.user=ctx.request.body.name userModel.insertData([ctx.request.body.name,md5(ctx.request.body.password)]) &#125; &#125;)&#125;)module.exports=router 我们使用md5实现密码加密 使用我们之前说的bodyParse来解析提交的数据，通过ctx.request.body得到 我们引入了数据库的操作 findDataByName和insertData。意思是先从数据库里面查找注册的用户名，如果找到了证明该用户名已经被注册过了，如果没有找到则使用insertData增加到数据库中 ctx.body 是我们通过ajax提交之后给页面返回的数据 我们使用ajax来提交数据，方便来做成功错误的处理 修改/views/signup.ejs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;% include header %&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input class=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input class=&quot;repeatpass&quot; type=&quot;password&quot; name=&quot;repeatpass&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; $(&apos;.submit&apos;).click(()=&gt;&#123; console.log($(&apos;.form&apos;).serialize()) $.ajax(&#123; url: &quot;/signup&quot;, data: $(&apos;.form&apos;).serialize(), type: &quot;POST&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (msg.data == 1) &#123; $(&apos;.error&apos;).text(&apos;用户名存在&apos;) $(&apos;input&apos;).val(&apos;&apos;) fade(&apos;.error&apos;) &#125; else if (msg.data == 2)&#123; $(&apos;.error&apos;).text(&apos;请输入重复的密码&apos;) fade(&apos;.error&apos;) &#125; else if(msg.data == 3)&#123; $(&apos;.success&apos;).text(&apos;注册成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/signin&quot; &#125;,1000) &#125; //console.log($(&apos;.ui.error.message&apos;).text); &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;) &lt;/script&gt;&lt;% include footer %&gt; 修改/views/header.ejs 我们之前在/routers/signup.js get ‘/signup’ 中 向模板传递了session参数 session:ctx.session,存取的就是用户的信息，包括用户名、登录之后的id等，之所以可以通过ctx.session获取到，因为我们在后面登录的时候已经赋值 如ctx.session.user=res[0][‘name’] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;koa-blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;header&gt; &lt;div class=&quot;user_name&quot;&gt; user： &lt;% if(session.user)&#123; %&gt; &lt;%= session.user %&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; 未登录 &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class=&quot;message&quot;&gt; &lt;div class=&quot;error&quot;&gt;&lt;/div&gt; &lt;div class=&quot;success&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;user_right&quot;&gt; &lt;% if(session.user)&#123; %&gt; &lt;div class=&quot;has_user&quot;&gt; &lt;a href=&quot;/posts&quot;&gt;全部文章&lt;/a&gt; &lt;a href=&quot;/create&quot;&gt;发表文章&lt;/a&gt; &lt;span class=&quot;signout&quot;&gt;登出&lt;/span&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; &lt;div class=&quot;none_user&quot;&gt; &lt;a href=&quot;/posts&quot;&gt;全部文章&lt;/a&gt; &lt;a href=&quot;/signup&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;/signin&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/header&gt; &lt;script&gt; function fade(data)&#123; if ($(data).css(&apos;display&apos;)!==&apos;none&apos;) &#123; $(data).fadeOut(1500) &#125; else&#123; $(data).show() $(data).fadeOut(1500) &#125; &#125; &lt;/script&gt; 我们可以看到当状态data为 3 的时候window.location.href=”/signin”为了方便跳转，我们先简单实现一下signin页面 修改 /routers/signin.js 12345678var router=require(&apos;koa-router&apos;)();router.get(&apos;/signin&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signin&apos;,&#123; session:ctx.session, &#125;)&#125;)module.exports=router 修改 /views/signin.ejs 123456789101112131415&lt;% include header %&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post &quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder=&quot;密码&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;登录&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;% include footer %&gt; 修改 index.js 文件 把下面这段代码注释去掉，之前注释是因为我们没有写signin的路由，以免报错，后面还有文章页和登出页的路由，大家记住一下 1app.use(require(&apos;./routers/signin.js&apos;).routes()) 现在注册一下来看看效果吧1$ supervisor --harmony index 我们怎么查看我们注册好的账号和密码呢？打开mysql控制台 1$ select * from users; 这样刚刚我们注册的用户信息都出现了]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Koa</tag>
        <tag>Mysql</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库（一）]]></title>
    <url>%2F2017%2F06%2F29%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面 读zepto源码，封装自己的zepto库系列是自己在读zepto源码的一些理解，有错误的地方还望指出。如果觉得本系列对你有所帮助，还请持续关注wclimb，谢谢。 zepto的整体架构首先来看看整体代码结构 123456789101112131415161718192021222324252627282930313233(function()&#123; var wclimb = &#123;&#125;,$ $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; wclimb.Z.prototype = Z.prototype = &#123; test:function()&#123; alert(1) &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wclimb = $&#125;)() 首先我们设置了一个闭包，避免产生全局变量123(function()&#123; ...&#125;)() 我们定义一个对象wclimb和$，以便后面使用 1var wclimb = &#123;&#125;,$ $函数返回了wclimb.init(selector),我们知道使用zepto的时候，一般是$(‘p’)，而selector就是p元素，当然不止这一种情况如$(function(){}),所以对选择器后面我们要做判断123$ = function(selector)&#123; return wclimb.init(selector)&#125; 而wclimb.init首先定义了一个dom，通过选择器选取的元素赋值给dom，最后返回wclimb.init，传入dom和选择元素selector 12345wclimb.init = function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector)&#125; 我们可以看到之前我们定义了对象wclimb，而后我们就往里面添加了一些方法，就像： 12345678910wclimb = &#123; init：function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector) &#125;, Z: function(dom,selector)&#123; return new Z(dom,selector) &#125;&#125; 通过wclimb.Z，如果有看过zepto源码的同学应该对此有了解.每次用$调用的时候,将直接返回一个Z的实例.达到无new调用的效果,$(‘p’)返回一个实例，然后$(‘p’).test()调用他的原形方法，这里的方法是test 1234567891011wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector)&#125;function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 由于我们是return new Z(dom,selector),那自然,我们需要手动的把wclimb.Z的prototype指向Z的prototype 123456789wclimb.Z.prototype = Z.prototype&#123;&#125;我们可以在里面添加方法了，如addClass eq等，我们试试加一个testwclimb.Z.prototype = Z.prototype&#123; test: function()&#123; console.log(&apos;test&apos;) &#125;&#125; Z函数是这样的，因为我们选择器选择的元素是一个数组（其实不是）我们把this指向选择的元素，然后添加两个元素selector和length，分别代表选择的元素名和元素的长度 1234567function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 最后我们在window上对外暴露一个接口,我们就可以用 $(‘p’) 或者wclimb(‘p’) 即可调用. 1window.$ = window.wclimb = $ 现在可以试试能不能运行 123html：&lt;p&gt;test&lt;/p&gt;js：$(&apos;p&apos;) 调用方法试试 $(&apos;p&apos;).test() 我们的zepto已经完成了，是不是很简单？骗你的，还差得远呢，后面会慢慢完善。待续。。。如果你觉得该文章帮助到了你，不妨star一下https://github.com/wclimb/wclimb.github.io ，感谢]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2017%2F06%2F28%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas仿微信红包 By wclimbHTML1&lt;canvas id=&quot;cav&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt; CSS 设置canvas的背景图 1234canvas&#123; background:url(https://b-ssl.duitang.com/uploads/item/201501/22/20150122203239_Cfr58.thumb.700_0.jpeg) no-repeat; background-size:100% 100%;&#125; JS12345678910111213141516171819202122232425262728293031323334353637var canvas = document.querySelector(&quot;#cav&quot;)var context = canvas.getContext(&quot;2d&quot;);var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30)context.globalAlpha = 0.96;context.fillStyle = &apos;#333&apos;context.rect(0,0,canvas.width,canvas.height);context.fill();context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore();var num = 30;var time = null;document.body.onclick = function()&#123; function circle()&#123; num += 5 context.save() context.beginPath() context.arc(randomX,randomY,num,0,Math.PI*2,false); context.clip(); context.clearRect(0,0,canvas.width,canvas.height) context.restore(); console.log(num) if (num &gt;= 677)&#123; clearInterval(timer) &#125; &#125; timer = setInterval(circle,10)&#125; 解析 随机出现圆心的位置，因为canvas为500*500 圆心为30 所以圆心的范围为 X(30,470) Y(470,30) 12var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30) 绘制矩形 透明度为0.96 填充颜色#333 宽高为canvas的宽高 最后用fill填充 1234context.globalAlpha = 0.96;context.fillStyle = &apos;#333&apos;context.rect(0,0,canvas.width,canvas.height);context.fill(); 初始化圆心的位置，用arc绘制圆，默认半径为30，用clip剪切，只有被剪切区域内是可见的 123456context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore(); 点击body的时候，设置定时器，让圆的半径每隔10毫秒增加5，当num半径大于677关闭定时器，677为canvas对角的长度 1document.body.onclick = function()&#123;&#125; 效果预览]]></content>
      <categories>
        <category>javascript</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp基础教程]]></title>
    <url>%2F2017%2F06%2F27%2Fgulp%2F</url>
    <content type="text"><![CDATA[入门指南–引用gulp官网示例 全局安装 gulp： 1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： 1$ npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 12345var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp： 1$ gulp //默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。 至此，一个简单的gulp已经完成，接下来让我们来完善部分功能 gulp功能完善生成package.json文件1$ npm init //一直回车，有需要的可以设置 安装所需包 使用淘宝镜像 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org示例 $ cnpm install [name] 接着1$ cnpm i browser-sync gulp gulp-clean-css gulp-imagemin gulp-rename gulp-sass gulp-uglify gulp.spritesmith gulp-autoprefixer --save 新建gulpfile.js文件添加123456789var gulp = require(&apos;gulp&apos;); var browserSync = require(&apos;browser-sync&apos;).create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require(&apos;gulp-sass&apos;); //sass转cssvar reload = browserSync.reload; var minifyCSS = require(&apos;gulp-clean-css&apos;) //css压缩var uglify = require(&apos;gulp-uglify&apos;) //js压缩var imagemin = require(&apos;gulp-imagemin&apos;) //图片压缩var rename = require(&apos;gulp-rename&apos;) //文件重命名var autoprefixer = require(&apos;gulp-autoprefixer&apos;) //自动添加前缀 设置默认文件地址12345678code为文件夹，里面存放html css js文件var src = &#123; scss: &apos;code/scss/*.scss&apos;, css: &apos;code/css/*.css&apos;, html: &apos;code/*.html&apos;, js: &apos;code/js/*.js&apos;, images: &apos;code/images/*.&#123;png,jpg,gif,ico&#125;&apos;&#125;; gulp.task(name[, deps], fn)123456789101112131415161718name: 任务的名字deps: 一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。fn: 该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。// 静态服务器 + 监听 scss/html 文件 gulp.task(&apos;serve&apos;, [&apos;sass&apos;], function() &#123; browserSync.init(&#123; server: &quot;./code&quot; &#125;); gulp.watch(src.scss, [&apos;sass&apos;]); gulp.watch(src.css, [&apos;css&apos;]); gulp.watch(src.images, [&apos;images&apos;]) gulp.watch(src.js, [&apos;js-watch&apos;]); gulp.watch(src.js, [&apos;js&apos;]); gulp.watch(src.html).on(&apos;change&apos;, reload);&#125;); scss编译后的css将注入到浏览器里实现更新123456789101112131415gulp.task(&apos;sass&apos;, function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;,//保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 雪碧图（有需要可以尝试）123456789101112var spritesmith = require(&apos;gulp.spritesmith&apos;); gulp.task(&apos;sprite&apos;, function () &#123; return gulp.src(&apos;code/images/*.png&apos;) .pipe(spritesmith(&#123; imgName:&apos;images/sprite20161010.png&apos;, //保存合并后图片的地址 cssName:&apos;css/sprite.css&apos;, //保存合并后对于css样式的地址 padding:20, algorithm:&apos;binary-tree&apos;, &#125;)) .pipe(gulp.dest(&apos;code/scss&apos;)); &#125;); 监听css文件1234567gulp.task(&apos;css&apos;, function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 监听js文件12345678910111213gulp.task(&apos;js&apos;, function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest(&apos;code/dest&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;)//监听js文件变化实现热加载gulp.task(&apos;js-watch&apos;, [&apos;js&apos;], browserSync.reload); 压缩图片任务12345678910// 在命令行输入 gulp images 启动此任务gulp.task(&apos;images&apos;, function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest(&apos;images&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 最后控制台输入gulp执行1gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 如果觉得帮助到了你，欢迎star -&gt; https://github.com/wclimb/wclimb.github.io 完整代码文件目录123456789101112-code -imgage 1.png -css default.css -scss default.scss -js default.js index.htmlgulpfile.jspackage.json packjson.js12345678910111213141516171819202122232425&#123; &quot;name&quot;: &quot;gulp-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Gulp &amp; SASS&quot;, &quot;main&quot;: &quot;gulpfile.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;gulp&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;browser-sync&quot;: &quot;^2.2.0&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-clean-css&quot;: &quot;^3.0.3&quot;, &quot;gulp-imagemin&quot;: &quot;^3.1.1&quot;, &quot;gulp-rename&quot;: &quot;^1.2.2&quot;, &quot;gulp-sass&quot;: &quot;^3.1.0&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.1&quot;, &quot;gulp.spritesmith&quot;: &quot;^6.4.0&quot;, &quot;gulp-autoprefixer&quot;: &quot;^4.0.0&quot; &#125;, &quot;dependencies&quot;: &#123; &#125;&#125; gulpfile.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106var gulp = require(&apos;gulp&apos;); var browserSync = require(&apos;browser-sync&apos;).create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require(&apos;gulp-sass&apos;); //sass转cssvar reload = browserSync.reload; var minifyCSS = require(&apos;gulp-clean-css&apos;) //css压缩var uglify = require(&apos;gulp-uglify&apos;) //js压缩var imagemin = require(&apos;gulp-imagemin&apos;) //图片压缩var rename = require(&apos;gulp-rename&apos;) //文件重命名var autoprefixer = require(&apos;gulp-autoprefixer&apos;) //自动添加前缀var src = &#123; scss: &apos;code/scss/*.scss&apos;, css: &apos;code/css/*.css&apos;, html: &apos;code/*.html&apos;, js: &apos;code/js/*.js&apos;, images: &apos;code/images/*.&#123;png,jpg,gif,ico&#125;&apos;&#125;;// 静态服务器 + 监听 scss/html 文件 gulp.task(&apos;serve&apos;, [&apos;sass&apos;], function() &#123; browserSync.init(&#123; server: &quot;./code&quot; &#125;); gulp.watch(src.scss, [&apos;sass&apos;]); gulp.watch(src.css, [&apos;css&apos;]); gulp.watch(src.images, [&apos;images&apos;]) gulp.watch(src.js, [&apos;js-watch&apos;]); gulp.watch(src.js, [&apos;js&apos;]); gulp.watch(src.html).on(&apos;change&apos;, reload);&#125;);// scss编译后的css将注入到浏览器里实现更新gulp.task(&apos;sass&apos;, function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;,//保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) //重新输出数据到某个文件夹，如果没有就会自动创建 .pipe(reload(&#123;stream: true&#125;));&#125;);// 雪碧图（有需要可以尝试）//var spritesmith = require(&apos;gulp.spritesmith&apos;); // gulp.task(&apos;sprite&apos;, function () &#123;// return gulp.src(&apos;code/images/*.png&apos;)// .pipe(spritesmith(&#123;// imgName:&apos;images/sprite20161010.png&apos;, //保存合并后图片的地址// cssName:&apos;css/sprite.css&apos;, //保存合并后对于css样式的地址// padding:20,// algorithm:&apos;binary-tree&apos;,// &#125;))// .pipe(gulp.dest(&apos;code/scss&apos;));// &#125;);gulp.task(&apos;css&apos;, function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task(&apos;js&apos;, function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest(&apos;code/dest&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;)//监听js文件变化实现热加载gulp.task(&apos;js-watch&apos;, [&apos;js&apos;], browserSync.reload);// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task(&apos;images&apos;, function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest(&apos;images&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]);]]></content>
      <categories>
        <category>javascript</category>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
</search>