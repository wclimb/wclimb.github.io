<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库（二）]]></title>
    <url>%2F2017%2F07%2F17%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[距离上一篇zepto源码分析已经过去大半个月，想想自己都过意不去，不过之前分享了一篇node博客教程，还算干了点正事。接下来我们继续封装自己的库吧 上节代码概览 12345678910111213141516171819202122232425262728293031323334(function()&#123; var wclimb = &#123;&#125;,$ $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom; dom = document.querySelectorAll(selector); return wclimb.Z(dom,selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; wclimb.Z.prototype = Z.prototype = &#123; test:function()&#123; alert(1) &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wclimb = $&#125;)() 选择器在wclimb.init=function(selector){}里面添加选择器代码12 each方法在wclimb.Z.prototype=Z.prototype=里面添加方法each 12345678wclimb.Z.prototype = Z.prototype = &#123; each:function(callback)&#123; [].every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this; &#125;&#125; 通过数组的every方法进行遍历，然后看看每次callback是不是都不是false，如果是则结束遍历 最后通过 return this 来达到链式调用的效果 addClass方法继续在里面添加addClass方法 123456789101112131415161718addClass:function(name)&#123; if (!name) return this return this.each(function(el,idx)&#123; if (!(&apos;className&apos; in this)) return classList = []; var cls = className(this) // newName = funcArg(this, name, idx, cls) name.split(/\s+/g).forEach(function(klass)&#123; // if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? &quot; &quot; : &quot;&quot;) + classList.join(&quot; &quot;)) &#125;)&#125; 我们先判断name存在与否，没有就直接return this，支持链式调用 新建一个数组，存放我们要添加的class，因为可能要同时添加多个 通过调用className方法来获取之前的class，并保存起来。clasName方法在下面 我们添加class一般是这样addClass(&#39;a b c&#39;)，所以我们通过正则表达式把他们用空格分开/\s+/g,用+的原因是，可能会有多个空格的存在，接着对他们进行循环 通过hasClass判断之前是否已经存在需要添加的class，如果有就push到classList数组里面。我们先注释掉hasClass这段代码，因为其中用到了$(this) ,querySelector是不支持的哟，所以后面我们得作判断，判断$()这里面放的是元素、函数、类数组等等。 最后通过函数className方法把他们用空格连接起来 发现里面有一个没有声明的className方法所以我们在wclimb.Z.prototype=Z.prototype=上面声明该函数1234567//获取或者设置classfunction className(node, value)&#123; var klass = node.className || &apos;&apos; if (value === undefined) return klass node.className = value&#125; 该方法主要是获取class和设置class的作用 hasClass方法12345678hasClass : function(cls) &#123; var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;); for (var i = 0; i &lt; this.length; i++) &#123; if (this[i].className.match(reg)) return true; return false; &#125; return this;&#125; 通过正则匹配，如果存在则返回true，否则返回false，最后return this支持链式调用 现在来试试效果吧12345html: &lt;p class=&quot;a&quot;&gt;&lt;/p&gt;js: $(&apos;p&apos;).addClass(&apos;test other&apos;) // &lt;p class=&quot;a test other&quot;&gt;&lt;/p&gt; console.log($(&apos;p&apos;).hasClass(&apos;a&apos;)) // true]]></content>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node+Koa2+Mysql 搭建简易博客]]></title>
    <url>%2F2017%2F07%2F12%2FNode-Koa2-Mysql-%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Koa2-blogNode+Koa2+Mysql 搭建简易博客 写在前面本篇教程一方面是为了自己在学习的过程加深记忆，也是总结的过程。另一方面给对这方面不太了解的同学以借鉴经验。如发现问题还望指正，如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wclimb/Koa2-blog下一篇可能是 Node + express + mongoose 或 zepto源码系列感谢您的阅读^_^ps：关于markdown代码缩进问题，看起来不太舒服，但复制到编辑器是正常的哟！ 演示效果 开发环境 nodejs v8.1.0 koa v2.3.0 mysql v5.7.0 准备工作文中用到了promise、async await等语法，所以你需要一点es6的语法，传送门当然是阮老师的教程了 http://es6.ruanyifeng.com/ 如果你已经配置好node和mysql可以跳过 1$ node -v 查看你的node版本，如果过低则去nodejs官网下载替换之前的版本 下载mysql，并设置好用户名和密码，默认可以为用户名：root，密码：123456 1进入到 bin 目录下 比如 cd C:\Program Files\MySQL\MySQL Server 5.7\bin 然后开启mysql1$ mysql -u root -p 输入密码之后创建database(数据库)，nodesql是我们创建的数据库1$ create database nodesql; 记住sql语句后面一定要跟;符号，接下来看看我们创建好的数据库列表 1$ show databases; 启用创建的数据库1$ use nodesql; 查看数据库中的表1$ show tables; 显示Empty set (0.00 sec)，因为我们还没有建表，稍后会用代码建表注释：这是后面建表之后的状态 目录结构 config 存放默认文件 lib 存放操作数据库文件 middlewares 存放判断登录与否文件 public 存放样式文件 routes 存放路由文件 views 存放模板文件 index 程序主文件 package.json 包括项目名、作者、依赖等等 首先我们创建koa2-blog文件夹，然后cd koa2-blog1接着使用 `npm init` 来创建package.json 接着安装包，安装之前我们使用cnpm安装1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 1$ cnpm i koa koa-bodyparser koa-mysql-session koa-router koa-session-minimal koa-static koa-views md5 moment mysql ejs --save 各模块用处 koa node框架 koa-bodyparser 表单解析中间件 koa-mysql-session、koa-session-minimal 处理数据库的中间件 koa-router 路由中间件 koa-static 静态资源加载中间件 ejs 模板引擎 md5 密码加密 moment 时间中间件 mysql 数据库 koa-views 模板呈现中间件 在文件夹里面新建所需文件 首先配置config我们新建default.js文件 123456789101112131415const config = &#123; // 启动端口 port: 3000, // 数据库配置 database: &#123; DATABASE: &apos;nodesql&apos;, USERNAME: &apos;root&apos;, PASSWORD: &apos;123456&apos;, PORT: &apos;3306&apos;, HOST: &apos;localhost&apos; &#125;&#125;module.exports = config 这是我们所需的一些字段，包括端口和数据库连接所需，最后我们把它exports暴露出去，以便可以在别的地方使用 配置index.js文件index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Koa=require(&apos;koa&apos;);var path=require(&apos;path&apos;)var bodyParser = require(&apos;koa-bodyparser&apos;);var ejs=require(&apos;ejs&apos;);var session = require(&apos;koa-session-minimal&apos;);var MysqlStore = require(&apos;koa-mysql-session&apos;);var config = require(&apos;./config/default.js&apos;);var router=require(&apos;koa-router&apos;)var views = require(&apos;koa-views&apos;)var koaStatic = require(&apos;koa-static&apos;)var app=new Koa()// session存储配置const sessionMysqlConfig= &#123; user: config.database.USERNAME, password: config.database.PASSWORD, database: config.database.DATABASE, host: config.database.HOST,&#125;// 配置session中间件app.use(session(&#123; key: &apos;USER_SID&apos;, store: new MysqlStore(sessionMysqlConfig)&#125;))// 配置静态资源加载中间件app.use(koaStatic( path.join(__dirname , &apos;./public&apos;)))// 配置服务端模板渲染引擎中间件app.use(views(path.join(__dirname, &apos;./views&apos;), &#123; extension: &apos;ejs&apos;&#125;))// 使用表单解析中间件app.use(bodyParser())// 使用新建的路由文件// app.use(require(&apos;./routers/signin.js&apos;).routes())app.use(require(&apos;./routers/signup.js&apos;).routes())// app.use(require(&apos;./routers/posts.js&apos;).routes())// app.use(require(&apos;./routers/signout.js&apos;).routes())// 监听在3000端口app.listen(3000)console.log(`listening on port $&#123;config.port&#125;`) 我们使用koa-session-minimal``koa-mysql-session来进行数据库的操作使用koa-static配置静态资源，目录设置为public使用ejs模板引擎使用koa-bodyparser来解析提交的表单信息使用koa-router做路由 之前我们配置了default.js，我们就可以在这里使用了首先引入进来 var config = require(‘./config/default.js’);然后在数据库的操作的时候，如config.database.USERNAME，得到的就是root。 如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wclimb/Koa2-blog 配置lib的mysql.js文件关于数据库的使用这里介绍一下，首先我们建立了数据库的连接池，以便后面的操作都可以使用到，我们创建了一个函数query，通过返回promise的方式以便可以方便用.then()来获取数据库返回的数据，然后我们定义了三个表的字段，通过createTable来创建我们后面所需的三个表，包括posts(存储文章)，users(存储用户)，comment(存储评论)，create table if not exists users()表示如果users表不存在则创建该表，避免每次重复建表报错的情况。后面我们定义了一系列的方法，最后把他们exports暴露出去。 这里只介绍注册用户insertData，后续的可以自行查看，都差不多 12345// 注册用户let insertData = function( value ) &#123; let _sql = &quot;insert into users(name,pass) values(?,?);&quot; return query( _sql, value )&#125; 我们写了一个_sql的sql语句，意思是插入到users的表中（在这之前我们已经建立了users表）然后要插入的数据分别是name和pass，就是用户名和密码，后面values(?,?)意思很简单，你有几个值就写几个问号，最后调用query函数把sql语句传进去 lib/mysql.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184var mysql = require(&apos;mysql&apos;);var config = require(&apos;../config/default.js&apos;)var pool = mysql.createPool(&#123; host : config.database.HOST, user : config.database.USERNAME, password : config.database.PASSWORD, database : config.database.DATABASE&#125;);let query = function( sql, values ) &#123; return new Promise(( resolve, reject ) =&gt; &#123; pool.getConnection(function(err, connection) &#123; if (err) &#123; resolve( err ) &#125; else &#123; connection.query(sql, values, ( err, rows) =&gt; &#123; if ( err ) &#123; reject( err ) &#125; else &#123; resolve( rows ) &#125; connection.release() &#125;) &#125; &#125;) &#125;)&#125;users=`create table if not exists users( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, pass VARCHAR(40) NOT NULL, PRIMARY KEY ( id ));`posts=`create table if not exists posts( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, title VARCHAR(40) NOT NULL, content VARCHAR(40) NOT NULL, uid VARCHAR(40) NOT NULL, moment VARCHAR(40) NOT NULL, comments VARCHAR(40) NOT NULL DEFAULT &apos;0&apos;, pv VARCHAR(40) NOT NULL DEFAULT &apos;0&apos;, PRIMARY KEY ( id ));`comment=`create table if not exists comment( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, content VARCHAR(40) NOT NULL, postid VARCHAR(40) NOT NULL, PRIMARY KEY ( id ));`let createTable = function( sql ) &#123; return query( sql, [] )&#125;// 建表createTable(users)createTable(posts)createTable(comment)// 注册用户let insertData = function( value ) &#123; let _sql = &quot;insert into users(name,pass) values(?,?);&quot; return query( _sql, value )&#125;// 发表文章let insertPost = function( value ) &#123; let _sql = &quot;insert into posts(name,title,content,uid,moment) values(?,?,?,?,?);&quot; return query( _sql, value )&#125;// 更新文章评论数let updatePostComment = function( value ) &#123; let _sql = &quot;update posts set comments=? where id=?&quot; return query( _sql, value )&#125;// 更新浏览数let updatePostPv = function( value ) &#123; let _sql = &quot;update posts set pv=? where id=?&quot; return query( _sql, value )&#125;// 发表评论let insertComment = function( value ) &#123; let _sql = &quot;insert into comment(name,content,postid) values(?,?,?);&quot; return query( _sql, value )&#125;// 通过名字查找用户let findDataByName = function ( name ) &#123; let _sql = ` SELECT * from users where name=&quot;$&#123;name&#125;&quot; ` return query( _sql)&#125;// 通过文章的名字查找用户let findDataByUser = function ( name ) &#123; let _sql = ` SELECT * from posts where name=&quot;$&#123;name&#125;&quot; ` return query( _sql)&#125;// 通过文章id查找let findDataById = function ( id ) &#123; let _sql = ` SELECT * from posts where id=&quot;$&#123;id&#125;&quot; ` return query( _sql)&#125;// 通过评论id查找let findCommentById = function ( id ) &#123; let _sql = ` SELECT * FROM comment where postid=&quot;$&#123;id&#125;&quot; ` return query( _sql)&#125;// 查询所有文章let findAllPost = function ( ) &#123; let _sql = ` SELECT * FROM posts ` return query( _sql)&#125;// 更新修改文章let updatePost = function(values)&#123; let _sql=`update posts set title=?,content=? where id=?` return query(_sql,values)&#125;// 删除文章let deletePost = function(id)&#123; let _sql=`delete from posts where id = $&#123;id&#125;` return query(_sql)&#125;// 删除评论let deleteComment = function(id)&#123; let _sql=`delete from comment where id = $&#123;id&#125;` return query(_sql)&#125;// 删除所有评论let deleteAllPostComment = function(id)&#123; let _sql=`delete from comment where postid = $&#123;id&#125;` return query(_sql)&#125;// 查找let findCommentLength = function(id)&#123; let _sql=`select content from comment where postid in (select id from posts where id=$&#123;id&#125;)` return query(_sql)&#125;module.exports=&#123; query, createTable, insertData, findDataByName, insertPost, findAllPost, findDataByUser, findDataById, insertComment, findCommentById, updatePost, deletePost, deleteComment, findCommentLength, updatePostComment, deleteAllPostComment, updatePostPv&#125; 下面是我们建的表 users posts comment id id id name name name pass title content content postid uid moment comments pv id主键递增 name: 用户名 pass：密码 title：文章标题 content：文章内容和评论 uid：发表文章的用户id moment：创建时间 comments：文章评论数 pv：文章浏览数 postid：文章id 现在感觉有点枯燥，那我们先来实现一下注册吧 实现注册页面routers/singup.js 12345678910var router=require(&apos;koa-router&apos;)();// GET &apos;/signup&apos; 注册页router.get(&apos;/signup&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signup&apos;,&#123; &#125;)&#125;)module.exports=router 使用get方式得到’/signup’页面，然后渲染signup模板，这里我们还没有在写signup.ejs views/signup.ejs 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input class=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input class=&quot;repeatpass&quot; type=&quot;password&quot; name=&quot;repeatpass&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们先安装supervisor 1$ cnpm i supervisor supervisor的作用是会监听文件的变化，而我们修改文件之后不必去重启程序1supervisor --harmony index 现在访问 localhost:3000/signup 看看效果吧。注意数据库一定要是开启的状态，不能关闭 完善注册功能首先我们来完善一下样式吧，稍微美化一下 public/index.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173body,header,ul,li,p,div,html,span,h3,a&#123; margin: 0; padding: 0; color: #333;&#125;body&#123; margin-bottom: 20px;&#125;a&#123; text-decoration: none;&#125;header&#123; width: 60%; margin: 20px auto; display: -webkit-flex; display: -moz-flex; display: -ms-flex; display: -o-flex; display: flex; justify-content: space-between;&#125;.user_name&#123; font-size: 20px;&#125;.has_user&#123; &#125;.has_user a,.has_user span,.none_user a&#123; padding: 5px 15px; background: #5FB878; border-radius: 15px; color: #fff; cursor: pointer;&#125;.posts&#123; list-style: none; width: 60%; margin: 0 auto;&#125;.posts li&#123; margin-top: 10px; border: 1px solid #ccc; border-radius: 5px; position: relative; padding-bottom: 50px;&#125;h3&#123; display: inline-block; padding: 5px 10px; background: #1E9FFF; color: #fff; border-radius: 10px;&#125;.post_title p,.post_content p&#123; margin: 10px 0; background: #eee; padding: 10px 20px; border: 1px solid #ddd; border-radius: 4px;&#125;.post_time&#123; position: absolute; bottom: 5px; right: 10px;&#125;.post_3&#123; position: absolute; bottom: 5px; left: 10px;&#125;.post_3 p&#123; display: inline-block; margin-left: 5px;&#125;.post_title&#123; padding: 10px 20px;&#125;.post_content&#123; padding: 0 20px;&#125;.spost&#123; width: 60%; margin:0 auto; border: 1px solid #ddd; position: relative; padding-bottom: 40px;&#125;.spost_user&#123; position: absolute; left: 20px; bottom: 5px;&#125;.edit&#123; position: absolute; right: 20px; bottom: 5px;&#125;.edit p&#123; display: inline-block; margin-left: 10px; &#125;.comment_wrap&#123; width: 60%; margin:20px auto; &#125;.submit&#123; display: block; width: 90px; height: 35px; line-height: 35px; text-align: center; border-radius: 10px; background: #5FB878; cursor: pointer; color: #fff; float: right; margin-top: 20px;&#125;.cmt_content&#123; background: #eee; padding: 20px ; position: relative;&#125;.cmt_name&#123; position: absolute; right: 20px; bottom: 5px;&#125;.cmt_name a&#123; margin-left: 10px;&#125;.cmt_content&#123; margin-top: 10px;&#125;.form&#123; margin:0 auto; width: 50%; margin-top: 20px;&#125;textarea&#123; width: 100%; height: 200px; padding-left: 20px; font-size: 20px;&#125;.container&#123; width: 60%; margin: 0 auto;&#125;input&#123; display: block; width: 100%; height: 40px; padding-left: 20px; font-size: 20px;&#125;.create label&#123; display: block; margin: 10px 0;&#125;.comment_wrap form&#123; width: 100%;&#125;.delete_comment,.delete_post&#123; cursor: pointer;&#125;.delete_comment:hover,.delete_post:hover&#123; color: #f60;&#125;a:hover&#123; color: #f60;&#125; 我们再把模板引擎的header和footer独立出来 /views/header.ejs顺便引入index.css和jq123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;body&gt; /views/footer.ejs 123 &lt;/body&gt;&lt;/html&gt; 修改views/signup.ejs 12345678910111213141516171819&lt;% include header %&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input class=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input class=&quot;repeatpass&quot; type=&quot;password&quot; name=&quot;repeatpass&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;% include footer %&gt; 修改routers/signup.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var router=require(&apos;koa-router&apos;)();// 处理数据库（之前已经写好，在mysql.js）var userModel=require(&apos;../lib/mysql.js&apos;);// 加密var md5=require(&apos;md5&apos;)router.get(&apos;/signup&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signup&apos;,&#123; session:ctx.session, &#125;)&#125;)// POST &apos;/signup&apos; 注册页router.post(&apos;/signup&apos;,async (ctx,next)=&gt;&#123; console.log(ctx.request.body) var user=&#123; name:ctx.request.body.name, pass:ctx.request.body.password, repeatpass:ctx.request.body.repeatpass &#125; await userModel.findDataByName(user.name) .then(result=&gt;&#123; // var res=JSON.parse(JSON.stringify(reslut)) console.log(result) if (result.length)&#123; try &#123; throw Error(&apos;用户存在&apos;) &#125;catch (error)&#123; //处理err console.log(error) &#125; ctx.body=&#123; data:1 &#125;;; &#125;else if (user.pass!==user.repeatpass || user.pass==&apos;&apos;)&#123; ctx.body=&#123; data:2 &#125;; &#125;else&#123; ctx.body=&#123; data:3 &#125;; console.log(&apos;注册成功&apos;) // ctx.session.user=ctx.request.body.name userModel.insertData([ctx.request.body.name,md5(ctx.request.body.password)]) &#125; &#125;)&#125;)module.exports=router 我们使用md5实现密码加密 使用我们之前说的bodyParse来解析提交的数据，通过ctx.request.body得到 我们引入了数据库的操作 findDataByName和insertData，因为之前我们在/lib/mysql.js中已经把他们写好，并暴露出来了。意思是先从数据库里面查找注册的用户名，如果找到了证明该用户名已经被注册过了，如果没有找到则使用insertData增加到数据库中 ctx.body 是我们通过ajax提交之后给页面返回的数据，比如提交ajax成功之后msg.data=1的时候就代表用户存在，msg.data出现在后面的signup.ejs模板ajax请求中 我们使用ajax来提交数据，方便来做成功错误的处理 模板引擎ejs我们使用的是ejs，语法可以见ejs官网 之前我们写了这么一段代码12345router.get(&apos;/signup&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signup&apos;,&#123; session:ctx.session, &#125;)&#125;) 这里就用到了ejs所需的session 我们通过渲染signup.ejs模板，将值ctx.session赋值给session，之后我们就可以在signup.ejs中使用了ejs的常用标签为： &lt;% code %&gt;：运行 JavaScript 代码，不输出 &lt;%= code %&gt;：显示转义后的 HTML内容 &lt;%- code %&gt;：显示原始 HTML 内容 &lt;%= code %&gt;和&lt;%- code %&gt;的区别在于，&lt;%= code %&gt;不管你写什么都会原样输出，比如code为 &lt;strong&gt;hello&lt;/strong&gt;的时候 &lt;%= code %&gt; 会显示&lt;strong&gt;hello&lt;/strong&gt;而&lt;%- code %&gt;则显示加粗的hello 修改/views/signup.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;% include header %&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input class=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input class=&quot;repeatpass&quot; type=&quot;password&quot; name=&quot;repeatpass&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; $(&apos;.submit&apos;).click(()=&gt;&#123; console.log($(&apos;.form&apos;).serialize()) $.ajax(&#123; url: &quot;/signup&quot;, data: $(&apos;.form&apos;).serialize(), type: &quot;POST&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (msg.data == 1) &#123; $(&apos;.error&apos;).text(&apos;用户名存在&apos;) $(&apos;input&apos;).val(&apos;&apos;) fade(&apos;.error&apos;) &#125; else if (msg.data == 2)&#123; $(&apos;.error&apos;).text(&apos;请输入重复的密码&apos;) fade(&apos;.error&apos;) &#125; else if(msg.data == 3)&#123; $(&apos;.success&apos;).text(&apos;注册成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/signin&quot; &#125;,1000) &#125; //console.log($(&apos;.ui.error.message&apos;).text); &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;) &lt;/script&gt;&lt;% include footer %&gt; 这里重点就在于ajax提交了，提交之后换回数据 1 2 3，然后分别做正确错误处理，把信息写在error和success中 修改/views/header.ejs 我们之前在/routers/signup.js get ‘/signup’ 中 向模板传递了session参数 session:ctx.session,存取的就是用户的信息，包括用户名、登录之后的id等，之所以可以通过ctx.session获取到，因为我们在后面登录的时候已经赋值 如ctx.session.user=res[0][‘name’] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;koa-blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;header&gt; &lt;div class=&quot;user_name&quot;&gt; user： &lt;% if(session.user)&#123; %&gt; &lt;%= session.user %&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; 未登录 &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class=&quot;message&quot;&gt; &lt;div class=&quot;error&quot;&gt;&lt;/div&gt; &lt;div class=&quot;success&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;user_right&quot;&gt; &lt;% if(session.user)&#123; %&gt; &lt;div class=&quot;has_user&quot;&gt; &lt;a href=&quot;/posts&quot;&gt;全部文章&lt;/a&gt; &lt;a href=&quot;/create&quot;&gt;发表文章&lt;/a&gt; &lt;span class=&quot;signout&quot;&gt;登出&lt;/span&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; &lt;div class=&quot;none_user&quot;&gt; &lt;a href=&quot;/posts&quot;&gt;全部文章&lt;/a&gt; &lt;a href=&quot;/signup&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;/signin&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/header&gt; &lt;script&gt; function fade(data)&#123; if ($(data).css(&apos;display&apos;)!==&apos;none&apos;) &#123; $(data).fadeOut(1500) &#125; else&#123; $(data).show() $(data).fadeOut(1500) &#125; &#125; &lt;/script&gt; 我们可以看到，如果不存在用户，则只显示全部文章 注册 登录 ,如果session.user存在则有登出的按钮 我们可以看到当状态data为 3 的时候window.location.href=”/signin”为了方便跳转，我们先简单实现一下signin页面 修改 /routers/signin.js 123456789var router=require(&apos;koa-router&apos;)();// get &apos;/signin&apos;登录页面router.get(&apos;/signin&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signin&apos;,&#123; session:ctx.session, &#125;)&#125;)module.exports=router 修改 /views/signin.ejs 123456789101112131415&lt;% include header %&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post &quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder=&quot;密码&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;登录&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;% include footer %&gt; 修改 index.js 文件 把下面这段代码注释去掉，之前注释是因为我们没有写signin的路由，以免报错，后面还有文章页和登出页的路由，大家记住一下 1app.use(require(&apos;./routers/signin.js&apos;).routes()) 现在注册一下来看看效果吧1$ supervisor --harmony index 我们怎么查看我们注册好的账号和密码呢？打开mysql控制台 1$ select * from users; 这样刚刚我们注册的用户信息都出现了 如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wclimb/Koa2-blog 登录页面修改signinrouters/signin.js 1234567891011121314151617181920212223242526272829303132333435363738394041var router=require(&apos;koa-router&apos;)();// 处理数据库（之前已经写好，在mysql.js）var userModel=require(&apos;../lib/mysql.js&apos;)// 加密var md5=require(&apos;md5&apos;)// get &apos;/signin&apos;登录页面router.get(&apos;/signin&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signin&apos;,&#123; session:ctx.session, &#125;)&#125;)// post &apos;/signin&apos;登录页面router.post(&apos;/signin&apos;,async (ctx,next)=&gt;&#123; console.log(ctx.request.body) var name=ctx.request.body.name; var pass=ctx.request.body.password; // 这里先查找用户名存在与否，存在则判断密码正确与否，不存在就返回false await userModel.findDataByName(name) .then(result =&gt;&#123; // console.log(reslut) var res=JSON.parse(JSON.stringify(result)) if (name === res[0][&apos;name&apos;] &amp;&amp; md5(pass) === res[0][&apos;pass&apos;]) &#123; ctx.body=&apos;true&apos; // ctx.flash.success=&apos;登录成功!&apos;; ctx.session.user=res[0][&apos;name&apos;] ctx.session.id=res[0][&apos;id&apos;] console.log(&apos;ctx.session.id&apos;,ctx.session.id) // ctx.redirect(&apos;/posts&apos;) console.log(&apos;session&apos;,ctx.session) console.log(&apos;登录成功&apos;) &#125; &#125;).catch(err=&gt;&#123; ctx.body=&apos;false&apos; console.log(&apos;用户名或密码错误!&apos;) // ctx.redirect(&apos;/signin&apos;) &#125;)&#125;)module.exports=router 我们进行登录操作，判断登录的用户名和密码是否有误，使用md5加密我们可以看到登录成功返回的结果是result 然后处理一下 var res=JSON.parse(JSON.stringify(result))为什么呢？因为返回的结果是这样的一个数组：id：4 name：rrr pass：…[ RowDataPacket { id: 4, name: ‘rrr’, pass: ‘44f437ced647ec3f40fa0841041871cd’ } ] 修改views/signin.ejssignin.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;% include header %&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post &quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder=&quot;密码&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;登录&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; $(&apos;.submit&apos;).click(()=&gt;&#123; console.log($(&apos;.form&apos;).serialize()) $.ajax(&#123; url: &quot;/signin&quot;, data: $(&apos;.form&apos;).serialize(), type: &quot;POST&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (!msg) &#123; $(&apos;.error&apos;).text(&apos;用户名或密码错误&apos;) $(&apos;input&apos;).val(&apos;&apos;) fade(&apos;.error&apos;) &#125; else&#123; $(&apos;.success&apos;).text(&apos;登录成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/posts&quot; &#125;,1000) &#125; //console.log($(&apos;.ui.error.message&apos;).text); &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;) &lt;/script&gt;&lt;% include footer %&gt; 我们增加了ajax请求，在routers/singin.js里，我们设置如果登录失败就返回false，登录成功返回true12ctx.body=&apos;false&apos;ctx.body=&apos;true&apos; 那我们登录成功后要做跳转，可以看到window.location.href=&quot;/posts&quot;跳转到posts页面 全部文章修改routers/posts.js posts.js 123456789101112131415161718var router=require(&apos;koa-router&apos;)();// 处理数据库（之前已经写好，在mysql.js）var userModel=require(&apos;../lib/mysql.js&apos;)// 时间中间件var moment=require(&apos;moment&apos;)// get &apos;/&apos;页面router.get(&apos;/&apos;,async (ctx,next)=&gt;&#123; ctx.redirect(&apos;/posts&apos;)&#125;)// get &apos;/posts&apos;页面router.get(&apos;/posts&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;posts&apos;,&#123; session:ctx.session &#125;) &#125;)module.exports=router 修改 index.js app.use(require(‘./routers/posts.js’).routes())的注释去掉 修改 views/posts.ejs 12345&lt;% include header %&gt; posts&lt;% include footer %&gt; 现在看看登录成功之后的页面吧 接下来我们事先登出页面 登出页面修改 router/signout.jssignout.js 12345678910var router=require(&apos;koa-router&apos;)();router.get(&apos;/signout&apos;,async (ctx,next)=&gt;&#123; ctx.session=null; console.log(&apos;登出成功&apos;) ctx.body=&apos;true&apos; &#125;)module.exports=router 把session设置为null即可 修改 index.js app.use(require(‘./routers/posts.js’).routes())的注释去掉，现在把注释的路由全部取消注释就对了 然后修改 views/header.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;koa-blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;header&gt; &lt;div class=&quot;user_name&quot;&gt; user： &lt;% if(session.user)&#123; %&gt; &lt;%= session.user %&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; 未登录 &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class=&quot;message&quot;&gt; &lt;div class=&quot;error&quot;&gt;&lt;/div&gt; &lt;div class=&quot;success&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;user_right&quot;&gt; &lt;% if(session.user)&#123; %&gt; &lt;div class=&quot;has_user&quot;&gt; &lt;a href=&quot;/posts&quot;&gt;全部文章&lt;/a&gt; &lt;a href=&quot;/create&quot;&gt;发表文章&lt;/a&gt; &lt;span class=&quot;signout&quot;&gt;登出&lt;/span&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; &lt;div class=&quot;none_user&quot;&gt; &lt;a href=&quot;/posts&quot;&gt;全部文章&lt;/a&gt; &lt;a href=&quot;/signup&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;/signin&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/header&gt; &lt;script&gt; function fade(data)&#123; if ($(data).css(&apos;display&apos;)!==&apos;none&apos;) &#123; $(data).fadeOut(1500) &#125; else&#123; $(data).show() $(data).fadeOut(1500) &#125; &#125; $(&apos;.signout&apos;).click(()=&gt;&#123; $.ajax(&#123; url: &quot;/signout&quot;, type: &quot;GET&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (msg) &#123; $(&apos;.success&apos;).text(&apos;登出成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/posts&quot; &#125;,1000) &#125; &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;) &lt;/script&gt; 增加点击登出后的ajax 的提交，成功之后回到posts页面 发表文章修改router/posts在后面增加12345678910111213141516171819202122232425// get &apos;/create&apos;router.get(&apos;/create&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;create&apos;,&#123; session:ctx.session, &#125;)&#125;)// psot &apos;/create&apos;router.post(&apos;/create&apos;,async (ctx,next)=&gt;&#123; console.log(ctx.session.user) var title=ctx.request.body.title var content=ctx.request.body.content var id=ctx.session.id var name=ctx.session.user var time=moment().format(&apos;YYYY-MM-DD HH:mm&apos;) console.log([name,title,content,id,time]) // 这里我们向数据库插入用户名、标题、内容、发表文章用户的id、时间，成功返回true，失败为false await userModel.insertPost([name,title,content,id,time]) .then(()=&gt;&#123; ctx.body=&apos;true&apos; &#125;).catch(()=&gt;&#123; ctx.body=&apos;false&apos; &#125;)&#125;) 修改 views/create.ejs create.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;% include header %&gt;&lt;div class=&quot;container&quot;&gt; &lt;form method=&quot;post&quot; class=&quot;form create&quot;&gt; &lt;div&gt; &lt;label&gt;标题：&lt;/label&gt; &lt;input placeholder=&quot;&quot; type=&quot;text&quot; name=&quot;title&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;内容：&lt;/label&gt; &lt;textarea name=&quot;content&quot; id=&quot;&quot; cols=&quot;42&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;发表&lt;/div&gt; &lt;/form&gt;&lt;/div&gt; &lt;script&gt; $(&apos;.submit&apos;).click(()=&gt;&#123; $.ajax(&#123; url: &quot;/create&quot;, data: $(&apos;.form&apos;).serialize(), type: &quot;POST&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (msg) &#123; $(&apos;.success&apos;).text(&apos;发表成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/posts&quot; &#125;,1000) &#125;else&#123; $(&apos;.success&apos;).text(&apos;发表失败&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.reload() &#125;,1000) &#125; &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;)&lt;/script&gt;&lt;% include footer %&gt; 现在看看能不能发表吧 即使我们发表了文章，但是当前我们的posts的页面没有显示，因为还没有获取到数据 接下来 修改 routers/posts.js 修改 get ‘/posts’ 12345678910111213141516171819202122232425262728router.get(&apos;/posts&apos;,async (ctx,next)=&gt;&#123; // 这里我们先通过查找有没有类似/posts?author=XXX 的连接跳转，如果有就执行下面这句话，把用户名取下来，由于用户名存在中文，所以我们进行解码 if (ctx.request.querystring) &#123; console.log(&apos;ctx.request.querystring&apos;,decodeURIComponent(ctx.request.querystring.split(&apos;=&apos;)[1])) await userModel.findDataByUser(decodeURIComponent(ctx.request.querystring.split(&apos;=&apos;)[1])) .then(result=&gt;&#123; res=JSON.parse(JSON.stringify(result)) console.log(res) &#125;) await ctx.render(&apos;posts&apos;,&#123; session:ctx.session, posts:res &#125;) &#125;else&#123; // 如果连接是正常的 如 /posts 则我们获取的是全部文章的列表，所以通过findAllPost查找全部文章并向模板传递数据posts， posts的值为res await userModel.findAllPost() .then(result=&gt;&#123; console.log(result) res=JSON.parse(JSON.stringify(result)) console.log(&apos;post&apos;,res) &#125;) await ctx.render(&apos;posts&apos;,&#123; session:ctx.session, posts:res &#125;) &#125;&#125;) if (ctx.request.querystring) {}这部分我们先不用管，后面会说。只需要看else后面的代码我们查找我们发表的全部文章然后将获取到的值定义为posts，传给模板posts.ejs，这样就可以渲染出来了 修改 Views/posts.ejs posts.ejs 123456789101112131415161718192021222324&lt;% include header %&gt; &lt;ul class=&quot;posts&quot;&gt; &lt;% posts.forEach(function(res)&#123; %&gt; &lt;li&gt; &lt;div class=&quot;post_3&quot;&gt; &lt;p class=&quot;post_user&quot;&gt;&lt;a href=&quot;/posts?author=&lt;%= res[&apos;name&apos;] %&gt;&quot;&gt;作者: &lt;%= res[&apos;name&apos;] %&gt;&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;post_comments&quot;&gt;评论数：&lt;%= res[&apos;comments&apos;] %&gt;&lt;/p&gt; &lt;p class=&quot;post_pv&quot;&gt;浏览数：&lt;%= res[&apos;pv&apos;] %&gt;&lt;/p&gt; &lt;/div&gt; &lt;a href=&quot;/posts/&lt;%= res[&apos;id&apos;] %&gt;&quot;&gt; &lt;div class=&quot;post_title&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;&lt;%= res[&apos;title&apos;] %&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;post_content&quot;&gt; &lt;h3&gt;content&lt;/h3&gt; &lt;p&gt;&lt;%= res[&apos;content&apos;] %&gt;&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;p class=&quot;post_time&quot;&gt;发表时间：&lt;%= res[&apos;moment&apos;] %&gt;&lt;/p&gt; &lt;/li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt;&lt;% include footer %&gt; 现在看看posts页面有没有文章出现了 我们看到是所有的文章，但是我需要点击单篇文章的时候，显示一篇文章怎么办呢？ 修改 routers/posts.js 在posts.js后面增加 1234567891011121314151617router.get(&apos;/posts/:postId&apos;,async (ctx,next)=&gt;&#123; console.log(ctx.params.postId) // 通过文章id查找返回数据，然后增加pv 浏览 +1 await userModel.findDataById(ctx.params.postId) .then(result=&gt;&#123; res=JSON.parse(JSON.stringify(result)) res_pv=parseInt(JSON.parse(JSON.stringify(result))[0][&apos;pv&apos;]) res_pv+=1 console.log(res) &#125;) // 渲染模板，并传递三个数据 await ctx.render(&apos;sPost&apos;,&#123; session:ctx.session, posts:res &#125;)&#125;) 现在的设计是，我们点进去出现的url是 /posts/1 这类的 1代表该篇文章的id，我们在数据库建表的时候就处理了，让id为主键，然后递增 我们通过userModel.findDataById 文章的id来查找数据库我们通过userModel.findCommentById 文章的id来查找文章的评论，因为单篇文章里面有评论的功能 单篇文章页修改 views/sPost.ejs sPost.ejs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;% include header %&gt; &lt;div class=&quot;spost&quot;&gt; &lt;p class=&quot;spost_user&quot;&gt;author: &lt;a href=&quot;/posts?author=&lt;%= posts[0][&apos;name&apos;] %&gt;&quot;&gt;&lt;%= posts[0][&apos;name&apos;] %&gt;&lt;/a&gt;&lt;/p&gt; &lt;div class=&quot;post_title&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;&lt;a href=&quot;/posts/&lt;%= posts[0][&apos;id&apos;] %&gt;&quot;&gt;&lt;%= posts[0][&apos;title&apos;] %&gt;&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;post_content&quot;&gt; &lt;h3&gt;content&lt;/h3&gt; &lt;p&gt;&lt;%= posts[0][&apos;content&apos;] %&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;edit&quot;&gt; &lt;% if(session &amp;&amp; session.user=== posts[0][&apos;name&apos;] )&#123; %&gt; &lt;p&gt;&lt;a href=&quot;&lt;%= posts[0][&apos;id&apos;] %&gt;/edit&quot;&gt;编辑&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a class=&quot;delete_post&quot; &gt;删除&lt;/a&gt;&lt;/p&gt; &lt;% &#125; %&gt; &lt;script&gt; $(&apos;.delete_post&apos;).click(()=&gt;&#123; $.ajax(&#123; url:&quot;&lt;%= posts[0][&apos;id&apos;] %&gt;/remove&quot;, type:&apos;GET&apos;, cache: false, success:function(msg)&#123; if (msg.data==1) &#123; $(&apos;.success&apos;).text(&apos;删除文章成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/posts&quot; &#125;,1000) &#125;else if(msg.data==2)&#123; $(&apos;.error&apos;).text(&apos;删除文章失败&apos;) fade(&apos;.error&apos;); setTimeout(()=&gt;&#123; window.location.reload() &#125;,1000) &#125; &#125; &#125;) &#125;) &lt;/script&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;comment_wrap&quot;&gt; &lt;h3&gt;comment&lt;/h3&gt; &lt;div class=&quot;comment_list&quot;&gt; &lt;% comments.forEach(function(res)&#123; %&gt; &lt;div class=&quot;cmt_lists&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;p class=&quot;cmt_content&quot;&gt; content: &lt;%= res[&apos;content&apos;] %&gt; &lt;span class=&quot;cmt_name&quot;&gt; By: &lt;%= res[&apos;name&apos;] %&gt; &lt;% if(session &amp;&amp; session.user === res[&apos;name&apos;] )&#123; %&gt; &lt;a class=&quot;delete_comment&quot;&gt; 删除&lt;/a&gt; &lt;% &#125; %&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; $(&apos;.delete_comment&apos;).click(()=&gt;&#123; $.ajax(&#123; url:&quot;&lt;%= posts[0][&apos;id&apos;] %&gt;/comment/&lt;%= res[&apos;id&apos;] %&gt;/remove&quot;, type:&apos;GET&apos;, cache: false, success:function(msg)&#123; if (msg.data==1) &#123; $(&apos;.success&apos;).text(&apos;删除留言成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.reload() &#125;,1000) &#125;else if(msg.data==2)&#123; $(&apos;.error&apos;).text(&apos;删除留言失败&apos;) fade(&apos;.error&apos;); setTimeout(()=&gt;&#123; window.location.reload() &#125;,1000) &#125; &#125;, error:function()&#123; alert(&apos;异常&apos;) &#125; &#125;) &#125;) &lt;/script&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;% if(session.user)&#123; %&gt; &lt;form class=&quot;form&quot; method=&quot;post&quot; action=&quot;/&lt;%= posts[0][&apos;id&apos;] %&gt;&quot;&gt; &lt;textarea name=&quot;content&quot; id=&quot;&quot;&gt;&lt;/textarea&gt; &lt;div class=&quot;submit&quot;&gt;发表留言&lt;/div&gt; &lt;/form&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;script&gt; $(&apos;.submit&apos;).click(function()&#123; $.ajax(&#123; url: &apos;/&apos;+document.URL.slice(document.URL.lastIndexOf(&apos;/&apos;)+1), data:$(&apos;.form&apos;).serialize(), type: &quot;POST&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (msg) &#123; $(&apos;.success&apos;).text(&apos;发表留言成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.reload() &#125;,1000) &#125; &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;) &lt;/script&gt; &lt;% include footer %&gt; 现在点击单篇文章试试，进入单篇文章页面，但是编辑、删除、评论都还没有做，点击无效，我们先不做，先实现每个用户发表的文章列表，我们之前在 get ‘/posts’ 里面说先忽略if (ctx.request.querystring) {}里面的代码，这里是做了应该处理，假如用户点击了某个用户，该用户发表了几篇文章，我们需要只显示该用户发表的文章，那么进入的url应该是 /posts?author=xxx ,这个处理在posts.ejs 就已经加上了，就在文章的左下角，作者：xxx就是一个链接。我们通过判断用户来查找文章，继而有了ctx.request.querystring 获取到的是：author=XXX 注：这里我们处理了，通过判断 session.user === res[&#39;name&#39;] 如果不是该用户发的文章，不能编辑和删除，评论也是。这里面也可以注意一下包裹的&lt;a href=&quot;&quot;&gt;&lt;/a&gt;标签 编辑文章、删除文章、评论、删除评论 评论 修改routers/posts.js 在post.js 后面增加 123456789101112131415161718192021router.post(&apos;/:postId&apos;,async (ctx,next)=&gt;&#123; var name=ctx.session.user var content=ctx.request.body.content var postId=ctx.params.postId // 插入评论的用户名，内容和文章id await userModel.insertComment([name,content,postId]) // 先通过文章id查找，然后评论数+1 await userModel.findDataById(postId) .then(result=&gt;&#123; res_comments=parseInt(JSON.parse(JSON.stringify(result))[0][&apos;comments&apos;]) res_comments+=1 &#125;) // 更新评论数 res_comments await userModel.updatePostComment([res_comments,postId]) .then(()=&gt;&#123; ctx.body=&apos;true&apos; &#125;).catch(()=&gt;&#123; ctx.body=&apos;false&apos; &#125;) &#125;) 现在试试发表评论的功能吧，之所以这样简单，因为我们之前就在sPost.ejs做了好几个ajax的处理，删除文章和评论也是如此 删除评论 修改routers/posts.js 继续在post.js 后面增加 1234567891011121314151617181920212223router.get(&apos;/posts/:postId/comment/:commentId/remove&apos;,async (ctx,next)=&gt;&#123; var postId=ctx.params.postId var commentId=ctx.params.commentId await userModel.findDataById(postId) .then(result=&gt;&#123; res_comments=parseInt(JSON.parse(JSON.stringify(result))[0][&apos;comments&apos;]) console.log(&apos;res&apos;,res_comments) res_comments-=1 console.log(res_comments) &#125;) await userModel.updatePostComment([res_comments,postId]) await userModel.deleteComment(commentId) .then(()=&gt;&#123; ctx.body=&#123; data:1 &#125; &#125;).catch(()=&gt;&#123; ctx.body=&#123; data:2 &#125; &#125;)&#125;) 现在试试删除评论的功能吧 删除文章 只有自己发表的文字删除的文字才会显示出来，才能被删除， 修改routers/posts.js 继续在post.js 后面增加 1234567891011121314151617router.get(&apos;/posts/:postId/remove&apos;,async (ctx,next)=&gt;&#123; var postId=ctx.params.postId await userModel.deleteAllPostComment(postId) await userModel.deletePost(postId) .then(()=&gt;&#123; ctx.body=&#123; data:1 &#125; &#125;).catch(()=&gt;&#123; ctx.body=&#123; data:2 &#125; &#125;) &#125;) 现在试试删除文章的功能吧 编辑文字 修改routers/posts.js 继续在post.js 后面增加 1234567891011121314151617181920212223242526272829// get &apos;/posts/:postId/edit&apos;router.get(&apos;/posts/:postId/edit&apos;,async (ctx,next)=&gt;&#123; var name=ctx.session.user var postId=ctx.params.postId await userModel.findDataById(postId) .then(result=&gt;&#123; res=JSON.parse(JSON.stringify(result)) console.log(&apos;修改文章&apos;,res) &#125;) await ctx.render(&apos;edit&apos;,&#123; session:ctx.session, posts:res &#125;)&#125;)// post &apos;/posts/:postId/edit&apos;router.post(&apos;/posts/:postId/edit&apos;,async (ctx,next)=&gt;&#123; var title=ctx.request.body.title var content=ctx.request.body.content var id=ctx.session.id var postId=ctx.params.postId await userModel.updatePost([title,content,postId]) .then(()=&gt;&#123; ctx.body=&apos;true&apos; &#125;).catch(()=&gt;&#123; ctx.body=&apos;false&apos; &#125;)&#125;) 修改views/edit.js 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;% include header %&gt;&lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;标题：&lt;/label&gt; &lt;input placeholder=&quot;标题&quot; type=&quot;text&quot; name=&quot;title&quot; value=&quot;&lt;%= posts[0][&apos;title&apos;] %&gt;&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;内容：&lt;/label&gt; &lt;textarea name=&quot;content&quot; id=&quot;&quot; cols=&quot;42&quot; rows=&quot;10&quot;&gt; &lt;%= posts[0][&apos;content&apos;] %&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;!-- &lt;input type=&quot;submit&quot; value=&quot;修改&quot;&gt; --&gt; &lt;div class=&quot;submit&quot;&gt;修改&lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt; $(&apos;.submit&apos;).click(()=&gt;&#123; $.ajax(&#123; url: document.URL, data: $(&apos;.form&apos;).serialize(), type: &quot;POST&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (msg) &#123; $(&apos;.success&apos;).text(&apos;修改成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/posts&quot; &#125;,1000) &#125; &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;)&lt;/script&gt;&lt;% include footer %&gt; 现在试试编辑文字然后修改提交吧 结语至此一个简单的blog就已经制作好了，其他扩展功能相信你已经会了吧！如果出现问题，还望积极提问哈，我会尽快处理的 所有的代码都在 https://github.com/wclimb/Koa2-blog 里面，如果觉得不错就star一下吧。有问题可以提问哟下一篇可能是 Node + express + mongoose 或 zepto源码系列感谢您的阅读^_^]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Node</tag>
        <tag>Koa</tag>
        <tag>Mysql</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库（一）]]></title>
    <url>%2F2017%2F06%2F29%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面 读zepto源码，封装自己的zepto库系列是自己在读zepto源码的一些理解，有错误的地方还望指出。如果觉得本系列对你有所帮助，还请持续关注wclimb，谢谢。 zepto的整体架构首先来看看整体代码结构 123456789101112131415161718192021222324252627282930313233(function()&#123; var wclimb = &#123;&#125;,$ $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom; dom = document.querySelectorAll(selector); return wclimb.Z(dom,selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; wclimb.Z.prototype = Z.prototype = &#123; test:function()&#123; alert(1) &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wclimb = $&#125;)() 首先我们设置了一个闭包，避免产生全局变量123(function()&#123; ...&#125;)() 我们定义一个对象wclimb和$，以便后面使用 1var wclimb = &#123;&#125;,$ $函数返回了wclimb.init(selector),我们知道使用zepto的时候，一般是$(‘p’)，而selector就是p元素，当然不止这一种情况如$(function(){}),所以对选择器后面我们要做判断123$ = function(selector)&#123; return wclimb.init(selector)&#125; 而wclimb.init首先定义了一个dom，通过选择器选取的元素赋值给dom，最后返回wclimb.init，传入dom和选择元素selector 12345wclimb.init = function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector)&#125; 我们可以看到之前我们定义了对象wclimb，而后我们就往里面添加了一些方法，就像： 12345678910wclimb = &#123; init：function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector) &#125;, Z: function(dom,selector)&#123; return new Z(dom,selector) &#125;&#125; 通过wclimb.Z，如果有看过zepto源码的同学应该对此有了解.每次用$调用的时候,将直接返回一个Z的实例.达到无new调用的效果,$(‘p’)返回一个实例，然后$(‘p’).test()调用他的原形方法，这里的方法是test 1234567891011wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector)&#125;function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 由于我们是return new Z(dom,selector),那自然,我们需要手动的把wclimb.Z的prototype指向Z的prototype 123456789wclimb.Z.prototype = Z.prototype&#123;&#125;我们可以在里面添加方法了，如addClass eq等，我们试试加一个testwclimb.Z.prototype = Z.prototype&#123; test: function()&#123; console.log(&apos;test&apos;) &#125;&#125; Z函数是这样的，因为我们选择器选择的元素是一个数组（其实不是）我们把this指向选择的元素，然后添加两个元素selector和length，分别代表选择的元素名和元素的长度 1234567function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 最后我们在window上对外暴露一个接口,我们就可以用 $(‘p’) 或者wclimb(‘p’) 即可调用. 1window.$ = window.wclimb = $ 现在可以试试能不能运行 123html：&lt;p&gt;test&lt;/p&gt;js：$(&apos;p&apos;) 调用方法试试 $(&apos;p&apos;).test() 我们的zepto已经完成了，是不是很简单？骗你的，还差得远呢，后面会慢慢完善。待续。。。如果你觉得该文章帮助到了你，不妨star一下https://github.com/wclimb/wclimb.github.io ，感谢]]></content>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2017%2F06%2F28%2Fcanvas%2F</url>
    <content type="text"><![CDATA[canvas仿微信红包 By wclimbHTML1&lt;canvas id=&quot;cav&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt; CSS 设置canvas的背景图 1234canvas&#123; background:url(https://b-ssl.duitang.com/uploads/item/201501/22/20150122203239_Cfr58.thumb.700_0.jpeg) no-repeat; background-size:100% 100%;&#125; JS12345678910111213141516171819202122232425262728293031323334353637var canvas = document.querySelector(&quot;#cav&quot;)var context = canvas.getContext(&quot;2d&quot;);var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30)context.globalAlpha = 0.96;context.fillStyle = &apos;#333&apos;context.rect(0,0,canvas.width,canvas.height);context.fill();context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore();var num = 30;var time = null;document.body.onclick = function()&#123; function circle()&#123; num += 5 context.save() context.beginPath() context.arc(randomX,randomY,num,0,Math.PI*2,false); context.clip(); context.clearRect(0,0,canvas.width,canvas.height) context.restore(); console.log(num) if (num &gt;= 677)&#123; clearInterval(timer) &#125; &#125; timer = setInterval(circle,10)&#125; 解析 随机出现圆心的位置，因为canvas为500*500 圆心为30 所以圆心的范围为 X(30,470) Y(470,30) 12var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30) 绘制矩形 透明度为0.96 填充颜色#333 宽高为canvas的宽高 最后用fill填充 1234context.globalAlpha = 0.96;context.fillStyle = &apos;#333&apos;context.rect(0,0,canvas.width,canvas.height);context.fill(); 初始化圆心的位置，用arc绘制圆，默认半径为30，用clip剪切，只有被剪切区域内是可见的 123456context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore(); 点击body的时候，设置定时器，让圆的半径每隔10毫秒增加5，当num半径大于677关闭定时器，677为canvas对角的长度 1document.body.onclick = function()&#123;&#125; 效果预览]]></content>
      <categories>
        <category>javascript</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2017%2F06%2F28%2Fcanvas%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E7%85%A7%E7%89%87%2F</url>
    <content type="text"><![CDATA[canvas仿微信红包照片 By wclimbHTML1&lt;canvas id=&quot;cav&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt; CSS 设置canvas的背景图 1234canvas&#123; background:url(https://b-ssl.duitang.com/uploads/item/201501/22/20150122203239_Cfr58.thumb.700_0.jpeg) no-repeat; background-size:100% 100%;&#125; JS12345678910111213141516171819202122232425262728293031323334353637var canvas = document.querySelector(&quot;#cav&quot;)var context = canvas.getContext(&quot;2d&quot;);var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30)context.globalAlpha = 0.96;context.fillStyle = &apos;#333&apos;context.rect(0,0,canvas.width,canvas.height);context.fill();context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore();var num = 30;var time = null;document.body.onclick = function()&#123; function circle()&#123; num += 5 context.save() context.beginPath() context.arc(randomX,randomY,num,0,Math.PI*2,false); context.clip(); context.clearRect(0,0,canvas.width,canvas.height) context.restore(); console.log(num) if (num &gt;= 677)&#123; clearInterval(timer) &#125; &#125; timer = setInterval(circle,10)&#125; 解析 随机出现圆心的位置，因为canvas为500*500 圆心为30 所以圆心的范围为 X(30,470) Y(470,30) 12var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30) 绘制矩形 透明度为0.96 填充颜色#333 宽高为canvas的宽高 最后用fill填充 1234context.globalAlpha = 0.96;context.fillStyle = &apos;#333&apos;context.rect(0,0,canvas.width,canvas.height);context.fill(); 初始化圆心的位置，用arc绘制圆，默认半径为30，用clip剪切，只有被剪切区域内是可见的 123456context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore(); 点击body的时候，设置定时器，让圆的半径每隔10毫秒增加5，当num半径大于677关闭定时器，677为canvas对角的长度 1document.body.onclick = function()&#123;&#125; 效果预览]]></content>
      <categories>
        <category>javascript</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp基础教程]]></title>
    <url>%2F2017%2F06%2F27%2Fgulp%2F</url>
    <content type="text"><![CDATA[入门指南–引用gulp官网示例 全局安装 gulp： 1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： 1$ npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 12345var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp： 1$ gulp //默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。 至此，一个简单的gulp已经完成，接下来让我们来完善部分功能 gulp功能完善生成package.json文件1$ npm init //一直回车，有需要的可以设置 安装所需包 使用淘宝镜像 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org示例 $ cnpm install [name] 接着1$ cnpm i browser-sync gulp gulp-clean-css gulp-imagemin gulp-rename gulp-sass gulp-uglify gulp.spritesmith gulp-autoprefixer --save 新建gulpfile.js文件添加123456789var gulp = require(&apos;gulp&apos;); var browserSync = require(&apos;browser-sync&apos;).create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require(&apos;gulp-sass&apos;); //sass转cssvar reload = browserSync.reload; var minifyCSS = require(&apos;gulp-clean-css&apos;) //css压缩var uglify = require(&apos;gulp-uglify&apos;) //js压缩var imagemin = require(&apos;gulp-imagemin&apos;) //图片压缩var rename = require(&apos;gulp-rename&apos;) //文件重命名var autoprefixer = require(&apos;gulp-autoprefixer&apos;) //自动添加前缀 设置默认文件地址12345678code为文件夹，里面存放html css js文件var src = &#123; scss: &apos;code/scss/*.scss&apos;, css: &apos;code/css/*.css&apos;, html: &apos;code/*.html&apos;, js: &apos;code/js/*.js&apos;, images: &apos;code/images/*.&#123;png,jpg,gif,ico&#125;&apos;&#125;; gulp.task(name[, deps], fn)123456789101112131415161718name: 任务的名字deps: 一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。fn: 该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。// 静态服务器 + 监听 scss/html 文件 gulp.task(&apos;serve&apos;, [&apos;sass&apos;], function() &#123; browserSync.init(&#123; server: &quot;./code&quot; &#125;); gulp.watch(src.scss, [&apos;sass&apos;]); gulp.watch(src.css, [&apos;css&apos;]); gulp.watch(src.images, [&apos;images&apos;]) gulp.watch(src.js, [&apos;js-watch&apos;]); gulp.watch(src.js, [&apos;js&apos;]); gulp.watch(src.html).on(&apos;change&apos;, reload);&#125;); scss编译后的css将注入到浏览器里实现更新123456789101112131415gulp.task(&apos;sass&apos;, function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;,//保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 雪碧图（有需要可以尝试）123456789101112var spritesmith = require(&apos;gulp.spritesmith&apos;); gulp.task(&apos;sprite&apos;, function () &#123; return gulp.src(&apos;code/images/*.png&apos;) .pipe(spritesmith(&#123; imgName:&apos;images/sprite20161010.png&apos;, //保存合并后图片的地址 cssName:&apos;css/sprite.css&apos;, //保存合并后对于css样式的地址 padding:20, algorithm:&apos;binary-tree&apos;, &#125;)) .pipe(gulp.dest(&apos;code/scss&apos;)); &#125;); 监听css文件1234567gulp.task(&apos;css&apos;, function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 监听js文件12345678910111213gulp.task(&apos;js&apos;, function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest(&apos;code/dest&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;)//监听js文件变化实现热加载gulp.task(&apos;js-watch&apos;, [&apos;js&apos;], browserSync.reload); 压缩图片任务12345678910// 在命令行输入 gulp images 启动此任务gulp.task(&apos;images&apos;, function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest(&apos;images&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 最后控制台输入gulp执行1gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 如果觉得帮助到了你，欢迎star -&gt; https://github.com/wclimb/wclimb.github.io 完整代码文件目录123456789101112-code -imgage 1.png -css default.css -scss default.scss -js default.js index.htmlgulpfile.jspackage.json packjson.js12345678910111213141516171819202122232425&#123; &quot;name&quot;: &quot;gulp-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Gulp &amp; SASS&quot;, &quot;main&quot;: &quot;gulpfile.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;gulp&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;browser-sync&quot;: &quot;^2.2.0&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-clean-css&quot;: &quot;^3.0.3&quot;, &quot;gulp-imagemin&quot;: &quot;^3.1.1&quot;, &quot;gulp-rename&quot;: &quot;^1.2.2&quot;, &quot;gulp-sass&quot;: &quot;^3.1.0&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.1&quot;, &quot;gulp.spritesmith&quot;: &quot;^6.4.0&quot;, &quot;gulp-autoprefixer&quot;: &quot;^4.0.0&quot; &#125;, &quot;dependencies&quot;: &#123; &#125;&#125; gulpfile.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106var gulp = require(&apos;gulp&apos;); var browserSync = require(&apos;browser-sync&apos;).create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require(&apos;gulp-sass&apos;); //sass转cssvar reload = browserSync.reload; var minifyCSS = require(&apos;gulp-clean-css&apos;) //css压缩var uglify = require(&apos;gulp-uglify&apos;) //js压缩var imagemin = require(&apos;gulp-imagemin&apos;) //图片压缩var rename = require(&apos;gulp-rename&apos;) //文件重命名var autoprefixer = require(&apos;gulp-autoprefixer&apos;) //自动添加前缀var src = &#123; scss: &apos;code/scss/*.scss&apos;, css: &apos;code/css/*.css&apos;, html: &apos;code/*.html&apos;, js: &apos;code/js/*.js&apos;, images: &apos;code/images/*.&#123;png,jpg,gif,ico&#125;&apos;&#125;;// 静态服务器 + 监听 scss/html 文件 gulp.task(&apos;serve&apos;, [&apos;sass&apos;], function() &#123; browserSync.init(&#123; server: &quot;./code&quot; &#125;); gulp.watch(src.scss, [&apos;sass&apos;]); gulp.watch(src.css, [&apos;css&apos;]); gulp.watch(src.images, [&apos;images&apos;]) gulp.watch(src.js, [&apos;js-watch&apos;]); gulp.watch(src.js, [&apos;js&apos;]); gulp.watch(src.html).on(&apos;change&apos;, reload);&#125;);// scss编译后的css将注入到浏览器里实现更新gulp.task(&apos;sass&apos;, function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;,//保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) //重新输出数据到某个文件夹，如果没有就会自动创建 .pipe(reload(&#123;stream: true&#125;));&#125;);// 雪碧图（有需要可以尝试）//var spritesmith = require(&apos;gulp.spritesmith&apos;); // gulp.task(&apos;sprite&apos;, function () &#123;// return gulp.src(&apos;code/images/*.png&apos;)// .pipe(spritesmith(&#123;// imgName:&apos;images/sprite20161010.png&apos;, //保存合并后图片的地址// cssName:&apos;css/sprite.css&apos;, //保存合并后对于css样式的地址// padding:20,// algorithm:&apos;binary-tree&apos;,// &#125;))// .pipe(gulp.dest(&apos;code/scss&apos;));// &#125;);gulp.task(&apos;css&apos;, function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task(&apos;js&apos;, function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest(&apos;code/dest&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;)//监听js文件变化实现热加载gulp.task(&apos;js-watch&apos;, [&apos;js&apos;], browserSync.reload);// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task(&apos;images&apos;, function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest(&apos;images&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]);]]></content>
      <categories>
        <category>javascript</category>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
</search>