<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL基础]]></title>
    <url>%2F2017%2F07%2F20%2FMySQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[转载至 mysql-tutorial 登录MySQL123456mysql -h 127.0.0.1 -u 用户名 -pmysql -D 所选择的数据库名 -h 主机名 -u 用户名 -pmysql&gt; exit # 退出 使用 “quit;” 或 “\q;” 一样的效果mysql&gt; status; # 显示当前mysql的version的各种信息mysql&gt; select version(); # 显示当前mysql的version信息mysql&gt; show global variables like 'port'; # 查看MySQL端口号 创建数据库对于表的操作需要先进入库use 库名; 12345678-- 创建一个名为 samp_db 的数据库，数据库字符编码指定为 gbkcreate database samp_db character set gbk;drop database samp_db; -- 删除 库名为samp_db的库show databases; -- 显示数据库列表。use samp_db; -- 选择创建的数据库samp_dbshow tables; -- 显示samp_db下面所有的表名字describe 表名; -- 显示数据表的结构delete from 表名; -- 清空表中记录 创建数据库表 使用 create table 语句可完成对表的创建, create table 的常见形式:语法：create table 表名称(列声明); 1234567891011121314-- 如果数据库中存在user_accounts表，就把它从数据库中drop掉DROP TABLE IF EXISTS `user_accounts`;CREATE TABLE `user_accounts` ( `id` int(100) unsigned NOT NULL AUTO_INCREMENT primary key, `password` varchar(32) NOT NULL DEFAULT '' COMMENT '用户密码', `reset_password` tinyint(32) NOT NULL DEFAULT 0 COMMENT '用户类型：0－不需要重置密码；1-需要重置密码', `mobile` varchar(20) NOT NULL DEFAULT '' COMMENT '手机', `create_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `update_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), -- 创建唯一索引，不允许重复 UNIQUE INDEX idx_user_mobile(`mobile`))ENGINE=InnoDB DEFAULT CHARSET=utf8COMMENT='用户表信息'; 数据类型的属性解释 NULL：数据列可包含NULL值； NOT NULL：数据列不允许包含NULL值； DEFAULT：默认值； PRIMARY：KEY 主键； AUTO_INCREMENT：自动递增，适用于整数类型； UNSIGNED：是指数值类型只能为正数； CHARACTER SET name：指定一个字符集； COMMENT：对表或者字段说明； 增删改查SELECT SELECT 语句用于从表中选取数据。语法：SELECT 列名称 FROM 表名称语法：SELECT * FROM 表名称 12345678910111213141516171819-- 表station取个别名叫s，表station中不包含 字段id=13或者14 的，并且id不等于4的 查询出来，只显示idSELECT s.id from station s WHERE id in (13,14) and id not in (4);-- 从表 Persons 选取 LastName 列的数据SELECT LastName FROM Persons-- 从表 users 选取 id=3 的数据，并只拉一条数据(据说能优化性能)SELECT * FROM users where id=3 limit 1-- 结果集中会自动去重复数据SELECT DISTINCT Company FROM Orders -- 表 Persons 字段 Id_P 等于 Orders 字段 Id_P 的值，-- 结果集显示 Persons表的 LastName、FirstName字段，Orders表的OrderNo字段SELECT p.LastName, p.FirstName, o.OrderNo FROM Persons p, Orders o WHERE p.Id_P = o.Id_P -- gbk 和 utf8 中英文混合排序最简单的办法 -- ci是 case insensitive, 即 “大小写不敏感”SELECT tag, COUNT(tag) from news GROUP BY tag order by convert(tag using gbk) collate gbk_chinese_ci;SELECT tag, COUNT(tag) from news GROUP BY tag order by convert(tag using utf8) collate utf8_unicode_ci; UPDATE Update 语句用于修改表中的数据。语法：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 12345-- update语句设置字段值为另一个结果取出来的字段update user set name = (select name from user1 where user1 .id = 1 )where id = (select id from user2 where user2 .name='小苏');-- 更新表 orders 中 id=1 的那一行数据更新它的 title 字段UPDATE `orders` set title='这里是标题' WHERE id=1; INSERT INSERT INTO 语句用于向表格中插入新的行。语法：INSERT INTO 表名称 VALUES (值1, 值2,....)语法：INSERT INTO 表名称 (列1, 列2,...) VALUES (值1, 值2,....) 123456789101112-- 向表 Persons 插入一条字段 LastName = JSLite 字段 Address = shanghaiINSERT INTO Persons (LastName, Address) VALUES ('JSLite', 'shanghai');-- 向表 meeting 插入 字段 a=1 和字段 b=2INSERT INTO meeting SET a=1,b=2;-- -- SQL实现将一个表的数据插入到另外一个表的代码-- 如果只希望导入指定字段，可以用这种方法：-- INSERT INTO 目标表 (字段1, 字段2, ...) SELECT 字段1, 字段2, ... FROM 来源表;INSERT INTO orders (user_account_id, title) SELECT m.user_id, m.title FROM meeting m where m.id=1;-- 向表 charger 插入一条数据，已存在就对表 charger 更新 `type`,`update_at` 字段；INSERT INTO `charger` (`id`,`type`,`create_at`,`update_at`) VALUES (3,2,'2017-05-18 11:06:17','2017-05-18 11:06:17') ON DUPLICATE KEY UPDATE `id`=VALUES(`id`), `type`=VALUES(`type`), `update_at`=VALUES(`update_at`); DELETE DELETE 语句用于删除表中的行。语法：DELETE FROM 表名称 WHERE 列名称 = 值 12345678-- 在不删除table_name表的情况下删除所有的行，清空表。DELETE FROM table_name-- 或者DELETE * FROM table_name-- 删除 Person表字段 LastName = 'JSLite' DELETE FROM Person WHERE LastName = 'JSLite' -- 删除 表meeting id 为2和3的两条数据DELETE from meeting where id in (2,3); WHERE WHERE 子句用于规定选择的标准。语法：SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 12-- 从表 Persons 中选出 Year 字段大于 1965 的数据SELECT * FROM Persons WHERE Year&gt;1965 AND 和 OR AND - 如果第一个条件和第二个条件都成立；OR - 如果第一个条件和第二个条件中只要有一个成立； AND1234567-- 删除 meeting 表字段 -- id=2 并且 user_id=5 的数据 和-- id=3 并且 user_id=6 的数据 DELETE from meeting where id in (2,3) and user_id in (5,6);-- 使用 AND 来显示所有姓为 "Carter" 并且名为 "Thomas" 的人：SELECT * FROM Persons WHERE FirstName='Thomas' AND LastName='Carter'; OR12-- 使用 OR 来显示所有姓为 "Carter" 或者名为 "Thomas" 的人：SELECT * FROM Persons WHERE firstname='Thomas' OR lastname='Carter' ORDER BY 语句默认按照升序对记录进行排序。ORDER BY - 语句用于根据指定的列对结果集进行排序。DESC - 按照降序对记录进行排序。ASC - 按照顺序对记录进行排序。 12345678-- Company在表Orders中为字母，则会以字母顺序显示公司名称SELECT Company, OrderNumber FROM Orders ORDER BY Company-- 后面跟上 DESC 则为降序显示SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC-- Company以降序显示公司名称，并OrderNumber以顺序显示SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC IN IN - 操作符允许我们在 WHERE 子句中规定多个值。IN - 操作符用来指定范围，范围中的每一条，都进行匹配。IN取值规律，由逗号分割，全部放置括号中。语法：SELECT &quot;字段名&quot;FROM &quot;表格名&quot;WHERE &quot;字段名&quot; IN (&#39;值一&#39;, &#39;值二&#39;, ...); 12-- 从表 Persons 选取 字段 LastName 等于 Adams、CarterSELECT * FROM Persons WHERE LastName IN ('Adams','Carter') NOT NOT - 操作符总是与其他操作符一起使用，用在要过滤的前面。 1SELECT vend_id, prod_name FROM Products WHERE NOT vend_id = 'DLL01' ORDER BY prod_name; UNION UNION - 操作符用于合并两个或多个 SELECT 语句的结果集。 123456789-- 列出所有在中国表（Employees_China）和美国（Employees_USA）的不同的雇员名SELECT E_Name FROM Employees_China UNION SELECT E_Name FROM Employees_USA-- 列出 meeting 表中的 pic_url，-- station 表中的 number_station 别名设置成 pic_url 避免字段不一样报错-- 按更新时间排序SELECT id,pic_url FROM meeting UNION ALL SELECT id,number_station AS pic_url FROM station ORDER BY update_at;-- 通过 UNION 语法同时查询了 products 表 和 comments 表的总记录数，并且按照 count 排序SELECT 'product' AS type, count(*) as count FROM `products` union select 'comment' as type, count(*) as count FROM `comments` order by count; AS as - 可理解为：用作、当成，作为；别名一般是重命名列名或者表名。语法：select column_1 as 列1,column_2 as 列2 from table as 表 12345678910111213141516SELECT * FROM Employee AS emp-- 这句意思是查找所有Employee 表里面的数据，并把Employee表格命名为 emp。-- 当你命名一个表之后，你可以在下面用 emp 代替 Employee.-- 例如 SELECT * FROM emp.SELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders-- 列出表 Orders 字段 OrderPrice 列最大值，-- 结果集列不显示 OrderPrice 显示 LargestOrderPrice-- 显示表 users_profile 中的 name 列SELECT t.name from (SELECT * from users_profile a) AS t;-- 表 user_accounts 命名别名 ua，表 users_profile 命名别名 up-- 满足条件 表 user_accounts 字段 id 等于 表 users_profile 字段 user_id-- 结果集只显示mobile、name两列SELECT ua.mobile,up.name FROM user_accounts as ua INNER JOIN users_profile as up ON ua.id = up.user_id; JOIN 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。 JOIN: 如果表中有至少一个匹配，则返回行 INNER JOIN:在表中存在至少一个匹配时，INNER JOIN 关键字返回行。 LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN: 只要其中一个表中存在匹配，就返回行 12345SELECT Persons.LastName, Persons.FirstName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P = Orders.Id_PORDER BY Persons.LastName; SQL 函数COUNT COUNT 让我们能够数出在表格中有多少笔资料被选出来。语法：SELECT COUNT(&quot;字段名&quot;) FROM &quot;表格名&quot;; 1234567-- 表 Store_Information 有几笔 store_name 栏不是空白的资料。-- "IS NOT NULL" 是 "这个栏位不是空白" 的意思。SELECT COUNT (Store_Name) FROM Store_Information WHERE Store_Name IS NOT NULL; -- 获取 Persons 表的总数SELECT COUNT(1) AS totals FROM Persons;-- 获取表 station 字段 user_id 相同的总数select user_id, count(*) as totals from station group by user_id; MAX MAX 函数返回一列中的最大值。NULL 值不包括在计算中。语法：SELECT MAX(&quot;字段名&quot;) FROM &quot;表格名&quot; 123-- 列出表 Orders 字段 OrderPrice 列最大值，-- 结果集列不显示 OrderPrice 显示 LargestOrderPriceSELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders 触发器 语法：create trigger &lt;触发器名称&gt;{ before | after} # 之前或者之后出发insert | update | delete # 指明了激活触发程序的语句的类型on &lt;表名&gt; # 操作哪张表for each row # 触发器的执行间隔，for each row 通知触发器每隔一行执行一次动作，而不是对整个表执行一次。&lt;触发器SQL语句&gt; 123456789101112delimiter $CREATE TRIGGER set_userdate BEFORE INSERT on `message`for EACH ROWBEGIN set @statu = new.status; -- 声明复制变量 statu if @statu = 0 then -- 判断 statu 是否等于 0 UPDATE `user_accounts` SET status=1 WHERE openid=NEW.openid; end if;END$DELIMITER ; -- 恢复结束符号 OLD和NEW不区分大小写 NEW 用NEW.col_name，没有旧行。在DELETE触发程序中，仅能使用OLD.col_name，没有新行。 OLD 用OLD.col_name来引用更新前的某一行的列 添加索引普通索引(INDEX) 语法：ALTER TABLE 表名字 ADD INDEX 索引名字 ( 字段名字 ) 1234567891011121314151617-- –直接创建索引CREATE INDEX index_user ON user(title)-- –修改表结构的方式添加索引ALTER TABLE table_name ADD INDEX index_name ON (column(length))-- 给 user 表中的 name字段 添加普通索引(INDEX)ALTER TABLE `table` ADD INDEX index_name (name)-- –创建表的时候同时创建索引CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT , `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL , `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL , `time` int(10) NULL DEFAULT NULL , PRIMARY KEY (`id`), INDEX index_name (title(length)))-- –删除索引DROP INDEX index_name ON table 主键索引(PRIMARY key) 语法：ALTER TABLE 表名字 ADD PRIMARY KEY ( 字段名字 ) 12-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)ALTER TABLE `user` ADD PRIMARY key (id); 唯一索引(UNIQUE) 语法：ALTER TABLE 表名字 ADD UNIQUE (字段名字) 12-- 给 user 表中的 creattime 字段添加唯一索引(UNIQUE)ALTER TABLE `user` ADD UNIQUE (creattime); 全文索引(FULLTEXT) 语法：ALTER TABLE 表名字 ADD FULLTEXT (字段名字) 12-- 给 user 表中的 description 字段添加全文索引(FULLTEXT)ALTER TABLE `user` ADD FULLTEXT (description); 添加多列索引 语法：ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3) 12-- 给 user 表中的 name、city、age 字段添加名字为name_city_age的普通索引(INDEX)ALTER TABLE user ADD INDEX name_city_age (name(10),city,age); 建立索引的时机在WHERE和JOIN中出现的列需要建立索引，但也不完全如此： MySQL只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN使用索引 某些时候的LIKE也会使用索引。 在LIKE以通配符%和_开头作查询时，MySQL不会使用索引。 12345678-- 此时就需要对city和age建立索引，-- 由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。SELECT t.Name FROM mytable t LEFT JOIN mytable m ON t.Name=m.username WHERE m.age=20 AND m.city='上海';SELECT * FROM mytable WHERE username like'admin%'; -- 而下句就不会使用：SELECT * FROM mytable WHEREt Name like'%admin'; -- 因此，在使用LIKE时应注意以上的区别。 索引的注意事项 索引不会包含有NULL值的列 使用短索引 不要在列上进行运算 索引会失效 创建后表的修改添加列 语法：alter table 表名 add 列名 列数据类型 [after 插入位置]; 示例: 123456-- 在表students的最后追加列 address: alter table students add address char(60);-- 在名为 age 的列后插入列 birthday: alter table students add birthday date after age;-- 在名为 number_people 的列后插入列 weeks: alter table students add column `weeks` varchar(5) not null default "" after `number_people`; 修改列 语法：alter table 表名 change 列名称 列新名称 新数据类型; 123456789-- 将表 tel 列改名为 telphone: alter table students change tel telphone char(13) default "-";-- 将 name 列的数据类型改为 char(16): alter table students change name name char(16) not null;-- 修改 COMMENT 前面必须得有类型属性alter table students change name name char(16) COMMENT '这里是名字';-- 修改列属性的时候 建议使用modify,不需要重建表-- change用于修改列名字，这个需要重建表alter table meeting modify `weeks` varchar(20) NOT NULL DEFAULT "" COMMENT "开放日期 周一到周日：0~6，间隔用英文逗号隔开"; 删除列 语法：alter table 表名 drop 列名称; 12-- 删除表students中的 birthday 列: alter table students drop birthday; 重命名表 语法：alter table 表名 rename 新表名; 12-- 重命名 students 表为 workmates: alter table students rename workmates; 清空表数据 方法一：delete from 表名;方法二：truncate from &quot;表名&quot;; DELETE:1. DML语言;2. 可以回退;3. 可以有条件的删除; TRUNCATE:1. DDL语言;2. 无法回退;3. 默认所有的表内容都删除;4. 删除速度比delete快。 1234-- 清空表为 workmates 里面的数据，不删除表。 delete from workmates;-- 删除workmates表中的所有数据，且无法恢复truncate from workmates; 删除整张表 语法：drop table 表名; 12-- 删除 workmates 表: drop table workmates; 删除整个数据库 语法：drop database 数据库名; 12-- 删除 samp_db 数据库: drop database samp_db;]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库 （三）]]></title>
    <url>%2F2017%2F07%2F18%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93-%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本篇着重讲选择器$()选择器本例我们主要修改wclimb.init=function(selector){}里面的代码将wclimb.init代码修改为：1234567891011121314151617181920var domif (!selector) return wclimb.Z()else if (typeof selector == &apos;string&apos;) &#123; dom = wclimb.qsa(document, selector)&#125;else if (typeof selector == &apos;function&apos;)&#123; return wclimb.ready(selector)&#125;else&#123; if (isArray(selector)) &#123; dom = compact(selector) &#125; else if (wclimb.isZ(selector)) return selector else&#123; if (isObject(selector)) dom = [selector], selector = null ; else dom=wclimb.qsa(document,selector) &#125;&#125;return wclimb.Z(dom, selector) 首先判断是否存在selector，如果不存在则直接return 然后判断是否是字符串类型，如$(&#39;a b&#39;)，将选择的元素保存起来 如果是函数则return wclimb.ready(selector)就是我们经常用的$(function(){}) 后面判断是否是当前对象的实例（用了isZ方法）还有判断是否是数组或对象 我们先在函数顶部添加如下123emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filterslice = emptyArray.slicefunction compact(array) &#123; return filter.call(array, function(item)&#123; return item != null &#125;) &#125; emptyArray = []，避免出现每次都重复创建的一个数组[]然后拿到数组里面的方法compact就是一个数组筛选，如果某个元素不存在$([1,2,,,4]);只会创建一个[1,2,4]的数组 wclimb.qsa方法1234567891011121314151617wclimb.qsa=function(element, selector)&#123; var found, maybeID = selector[0] == &apos;#&apos;, maybeClass = !maybeID &amp;&amp; selector[0] == &apos;.&apos;, nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked isSimple = /^[\w-]*$/.test(nameOnly) return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? // Safari DocumentFragment doesn&apos;t have getElementById ( (found = element.getElementById(nameOnly)) ? [found] : [] ) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // DocumentFragment doesn&apos;t have getElementsByClassName/TagName maybeClass ? element.getElementsByClassName(nameOnly) : // If it&apos;s simple, it could be a class element.getElementsByTagName(selector) : // Or a tag element.querySelectorAll(selector) // Or it&apos;s not simple, and we need to query all )&#125; 这里我直接用了zepto的代码wclimb.init=function(selector){}里的代码还使用了判断数据类型的代码isArray``isObject 判断数据类型在函数外面添加如下代码来进行数据类型判断 123456789101112// 判断类型var obj_i=&#123;&#125;;[&apos;Boolean&apos;, &apos;Number&apos;,&apos;String&apos;, &apos;Function&apos;, &apos;Array&apos; ,&apos;Date&apos;, &apos;RegExp&apos;, &apos;Object&apos; ,&apos;Error&apos;].forEach(function(el,idx)&#123; obj_i[&quot;[object &quot; + el + &quot;]&quot;] = el.toLowerCase()&#125;)function type(obj) &#123; return obj == null ? String(obj) : obj_i[Object.prototype.toString.call(obj)] || &quot;object&quot;&#125;function isObject(obj) &#123; return type(obj) == &quot;object&quot; &#125; function isArray(obj) &#123; return type(obj) == &quot;array&quot; &#125;function isString(obj) &#123; return type(obj) == &quot;string&quot; &#125; wclimb.ready函数在外面设置如下函数123456wclimb.ready = function(fn) &#123; document.addEventListener(&apos;DOMContentLoaded&apos;,function() &#123; fn &amp;&amp; fn(); &#125;,false); document.removeEventListener(&apos;DOMContentLoaded&apos;,fn,true);&#125;; wclimb.isZ函数下面代码判断object是不是wclimb.Z的实例123wclimb.isZ = function(object) &#123; return object instanceof wclimb.Z&#125; 现在试试代码吧，我们顺便把addClass里判断hasClass代码注释去掉了 123456789101112&lt;script&gt; // ready $(function()&#123; alert(1) &#125;) // addClass $(&apos;p&apos;).addClass(&apos;a b&apos;) // 实例 console.log($(this)) // 数组 $([1,23,3,,4])&lt;/script&gt; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131(function()&#123; var wclimb = &#123;&#125;,$ emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter slice = emptyArray.slice function compact(array) &#123; return filter.call(array, function(item)&#123; return item != null &#125;) &#125; $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom if (!selector) return wclimb.Z() else if (typeof selector == &apos;string&apos;) &#123; dom = wclimb.qsa(document, selector) &#125; else if (typeof selector == &apos;function&apos;)&#123; return wclimb.ready(selector) &#125; else&#123; if (isArray(selector)) &#123; dom = compact(selector) &#125; else if (wclimb.isZ(selector)) return selector else&#123; if (isObject(selector)) dom = [selector], selector = null ; else dom=wclimb.qsa(document,selector) &#125; &#125; return wclimb.Z(dom, selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; function className(node, value)&#123; var klass = node.className || &apos;&apos; if (value === undefined) return klass node.className = value &#125; wclimb.Z.prototype = Z.prototype = &#123; each:function(callback)&#123; [].every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this; &#125;, addClass:function(name)&#123; if (!name) return this return this.each(function(el,idx)&#123; if (!(&apos;className&apos; in this)) return classList = []; var cls = className(this) name.split(/\s+/g).forEach(function(klass)&#123; if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? &quot; &quot; : &quot;&quot;) + classList.join(&quot; &quot;)) &#125;) &#125;, hasClass : function(cls) &#123; var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;); for (var i = 0; i &lt; this.length; i++) &#123; if (this[i].className.match(reg)) return true; return false; &#125; return this; &#125; &#125; wclimb.ready = function(fn) &#123; document.addEventListener(&apos;DOMContentLoaded&apos;,function() &#123; fn &amp;&amp; fn(); &#125;,false); document.removeEventListener(&apos;DOMContentLoaded&apos;,fn,true); &#125;; wclimb.qsa=function(element, selector)&#123; var found, maybeID = selector[0] == &apos;#&apos;, maybeClass = !maybeID &amp;&amp; selector[0] == &apos;.&apos;, nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked isSimple = /^[\w-]*$/.test(nameOnly) return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? // Safari DocumentFragment doesn&apos;t have getElementById ( (found = element.getElementById(nameOnly)) ? [found] : [] ) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // DocumentFragment doesn&apos;t have getElementsByClassName/TagName maybeClass ? element.getElementsByClassName(nameOnly) : // If it&apos;s simple, it could be a class element.getElementsByTagName(selector) : // Or a tag element.querySelectorAll(selector) // Or it&apos;s not simple, and we need to query all ) &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; wclimb.isZ = function(object) &#123; return object instanceof wclimb.Z &#125; // 判断类型 var obj_i=&#123;&#125;; [&apos;Boolean&apos;, &apos;Number&apos;,&apos;String&apos;, &apos;Function&apos;, &apos;Array&apos; ,&apos;Date&apos;, &apos;RegExp&apos;, &apos;Object&apos; ,&apos;Error&apos;].forEach(function(el,idx)&#123; obj_i[&quot;[object &quot; + el + &quot;]&quot;] = el.toLowerCase() &#125;) function type(obj) &#123; return obj == null ? String(obj) : obj_i[Object.prototype.toString.call(obj)] || &quot;object&quot; &#125; function isObject(obj) &#123; return type(obj) == &quot;object&quot; &#125; function isArray(obj) &#123; return type(obj) == &quot;array&quot; &#125; function isString(obj) &#123; return type(obj) == &quot;string&quot; &#125; window.$ = window.wclimb = $&#125;)()]]></content>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库（二）]]></title>
    <url>%2F2017%2F07%2F17%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[距离上一篇zepto源码分析已经过去大半个月，想想自己都过意不去，不过之前分享了一篇node博客教程，还算干了点正事。接下来我们继续封装自己的库吧 上节代码概览12345678910111213141516171819202122232425262728293031323334(function()&#123; var wclimb = &#123;&#125;,$ $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom; dom = document.querySelectorAll(selector); return wclimb.Z(dom,selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; wclimb.Z.prototype = Z.prototype = &#123; test:function()&#123; alert(1) &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wclimb = $&#125;)() each方法 在wclimb.Z.prototype=Z.prototype=里面添加方法each 12345678wclimb.Z.prototype = Z.prototype = &#123; each:function(callback)&#123; [].every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this; &#125;&#125; 通过数组的every方法进行遍历，然后看看每次callback是不是都不是false，如果是则结束遍历 最后通过 return this 来达到链式调用的效果 addClass方法继续在里面添加addClass方法 123456789101112131415161718addClass:function(name)&#123; if (!name) return this return this.each(function(el,idx)&#123; if (!(&apos;className&apos; in this)) return classList = []; var cls = className(this) // newName = funcArg(this, name, idx, cls) name.split(/\s+/g).forEach(function(klass)&#123; // if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? &quot; &quot; : &quot;&quot;) + classList.join(&quot; &quot;)) &#125;)&#125; 我们先判断name存在与否，没有就直接return this，支持链式调用 新建一个数组，存放我们要添加的class，因为可能要同时添加多个 通过调用className方法来获取之前的class，并保存起来。clasName方法在下面 我们添加class一般是这样addClass(&#39;a b c&#39;)，所以我们通过正则表达式把他们用空格分开/\s+/g,用+的原因是，可能会有多个空格的存在，接着对他们进行循环 通过hasClass判断之前是否已经存在需要添加的class，如果有就push到classList数组里面。我们先注释掉hasClass这段代码，因为其中用到了$(this) ,querySelector是不支持的哟，所以后面我们得作判断，判断$()这里面放的是元素、函数、类数组等等。 最后通过函数className方法把他们用空格连接起来 发现里面有一个没有声明的className方法所以我们在wclimb.Z.prototype=Z.prototype=上面声明该函数1234567//获取或者设置classfunction className(node, value)&#123; var klass = node.className || &apos;&apos; if (value === undefined) return klass node.className = value&#125; 该方法主要是获取class和设置class的作用 hasClass方法12345678hasClass : function(cls) &#123; var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;); for (var i = 0; i &lt; this.length; i++) &#123; if (this[i].className.match(reg)) return true; return false; &#125; return this;&#125; 通过正则匹配，如果存在则返回true，否则返回false，最后return this支持链式调用 现在来试试效果吧12345html: &lt;p class=&quot;a&quot;&gt;&lt;/p&gt;js: $(&apos;p&apos;).addClass(&apos;test other&apos;) // &lt;p class=&quot;a test other&quot;&gt;&lt;/p&gt; console.log($(&apos;p&apos;).hasClass(&apos;a&apos;)) // true 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273(function()&#123; var wclimb = &#123;&#125;,$ $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom; dom = document.querySelectorAll(selector); return wclimb.Z(dom,selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; function className(node, value)&#123;//获取或者设置class var klass = node.className || &apos;&apos; if (value === undefined) return klass node.className = value &#125; wclimb.Z.prototype = Z.prototype = &#123; each:function(callback)&#123; [].every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this; &#125;, addClass:function(name)&#123; if (!name) return this return this.each(function(el,idx)&#123; if (!(&apos;className&apos; in this)) return classList = []; var cls = className(this) name.split(/\s+/g).forEach(function(klass)&#123; // if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? &quot; &quot; : &quot;&quot;) + classList.join(&quot; &quot;)) &#125;) &#125;, hasClass : function(cls) &#123; var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;); for (var i = 0; i &lt; this.length; i++) &#123; if (this[i].className.match(reg)) return true; return false; &#125; return this; &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wclimb = $&#125;)()]]></content>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node+Koa2+Mysql 搭建简易博客]]></title>
    <url>%2F2017%2F07%2F12%2FNode-Koa2-Mysql-%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Koa2-blogNode+Koa2+Mysql 搭建简易博客 写在前面本篇教程一方面是为了自己在学习的过程加深记忆，也是总结的过程。另一方面给对这方面不太了解的同学以借鉴经验。如发现问题还望指正，如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wclimb/Koa2-blog下一篇可能是 Node + express + mongoose 或 zepto源码系列感谢您的阅读^_^ps：关于markdown代码缩进问题，看起来不太舒服，但复制到编辑器是正常的哟！ 演示效果 开发环境 nodejs v8.1.0 koa v2.3.0 mysql v5.7.0 准备工作文中用到了promise、async await等语法，所以你需要一点es6的语法，传送门当然是阮老师的教程了 http://es6.ruanyifeng.com/ 如果你已经配置好node和mysql可以跳过 1$ node -v 查看你的node版本，如果过低则去nodejs官网下载替换之前的版本 下载mysql，并设置好用户名和密码，默认可以为用户名：root，密码：123456 1进入到 bin 目录下 比如 cd C:\Program Files\MySQL\MySQL Server 5.7\bin 然后开启mysql1$ mysql -u root -p 输入密码之后创建database(数据库)，nodesql是我们创建的数据库1$ create database nodesql; 记住sql语句后面一定要跟;符号，接下来看看我们创建好的数据库列表 1$ show databases; 启用创建的数据库1$ use nodesql; 查看数据库中的表1$ show tables; 显示Empty set (0.00 sec)，因为我们还没有建表，稍后会用代码建表注释：这是后面建表之后的状态 目录结构 config 存放默认文件 lib 存放操作数据库文件 middlewares 存放判断登录与否文件 public 存放样式文件 routes 存放路由文件 views 存放模板文件 index 程序主文件 package.json 包括项目名、作者、依赖等等 首先我们创建koa2-blog文件夹，然后cd koa2-blog1接着使用 `npm init` 来创建package.json 接着安装包，安装之前我们使用cnpm安装1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 1$ cnpm i koa koa-bodyparser koa-mysql-session koa-router koa-session-minimal koa-static koa-views md5 moment mysql ejs --save 各模块用处 koa node框架 koa-bodyparser 表单解析中间件 koa-mysql-session、koa-session-minimal 处理数据库的中间件 koa-router 路由中间件 koa-static 静态资源加载中间件 ejs 模板引擎 md5 密码加密 moment 时间中间件 mysql 数据库 koa-views 模板呈现中间件 在文件夹里面新建所需文件 首先配置config我们新建default.js文件 123456789101112131415const config = &#123; // 启动端口 port: 3000, // 数据库配置 database: &#123; DATABASE: &apos;nodesql&apos;, USERNAME: &apos;root&apos;, PASSWORD: &apos;123456&apos;, PORT: &apos;3306&apos;, HOST: &apos;localhost&apos; &#125;&#125;module.exports = config 这是我们所需的一些字段，包括端口和数据库连接所需，最后我们把它exports暴露出去，以便可以在别的地方使用 配置index.js文件index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Koa=require(&apos;koa&apos;);var path=require(&apos;path&apos;)var bodyParser = require(&apos;koa-bodyparser&apos;);var ejs=require(&apos;ejs&apos;);var session = require(&apos;koa-session-minimal&apos;);var MysqlStore = require(&apos;koa-mysql-session&apos;);var config = require(&apos;./config/default.js&apos;);var router=require(&apos;koa-router&apos;)var views = require(&apos;koa-views&apos;)var koaStatic = require(&apos;koa-static&apos;)var app=new Koa()// session存储配置const sessionMysqlConfig= &#123; user: config.database.USERNAME, password: config.database.PASSWORD, database: config.database.DATABASE, host: config.database.HOST,&#125;// 配置session中间件app.use(session(&#123; key: &apos;USER_SID&apos;, store: new MysqlStore(sessionMysqlConfig)&#125;))// 配置静态资源加载中间件app.use(koaStatic( path.join(__dirname , &apos;./public&apos;)))// 配置服务端模板渲染引擎中间件app.use(views(path.join(__dirname, &apos;./views&apos;), &#123; extension: &apos;ejs&apos;&#125;))// 使用表单解析中间件app.use(bodyParser())// 使用新建的路由文件// app.use(require(&apos;./routers/signin.js&apos;).routes())app.use(require(&apos;./routers/signup.js&apos;).routes())// app.use(require(&apos;./routers/posts.js&apos;).routes())// app.use(require(&apos;./routers/signout.js&apos;).routes())// 监听在3000端口app.listen(3000)console.log(`listening on port $&#123;config.port&#125;`) 我们使用koa-session-minimal``koa-mysql-session来进行数据库的操作使用koa-static配置静态资源，目录设置为public使用ejs模板引擎使用koa-bodyparser来解析提交的表单信息使用koa-router做路由 之前我们配置了default.js，我们就可以在这里使用了首先引入进来 var config = require(‘./config/default.js’);然后在数据库的操作的时候，如config.database.USERNAME，得到的就是root。 如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wclimb/Koa2-blog 配置lib的mysql.js文件关于数据库的使用这里介绍一下，首先我们建立了数据库的连接池，以便后面的操作都可以使用到，我们创建了一个函数query，通过返回promise的方式以便可以方便用.then()来获取数据库返回的数据，然后我们定义了三个表的字段，通过createTable来创建我们后面所需的三个表，包括posts(存储文章)，users(存储用户)，comment(存储评论)，create table if not exists users()表示如果users表不存在则创建该表，避免每次重复建表报错的情况。后面我们定义了一系列的方法，最后把他们exports暴露出去。 这里只介绍注册用户insertData，后续的可以自行查看，都差不多 12345// 注册用户let insertData = function( value ) &#123; let _sql = &quot;insert into users(name,pass) values(?,?);&quot; return query( _sql, value )&#125; 我们写了一个_sql的sql语句，意思是插入到users的表中（在这之前我们已经建立了users表）然后要插入的数据分别是name和pass，就是用户名和密码，后面values(?,?)意思很简单，你有几个值就写几个问号，最后调用query函数把sql语句传进去 lib/mysql.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184var mysql = require(&apos;mysql&apos;);var config = require(&apos;../config/default.js&apos;)var pool = mysql.createPool(&#123; host : config.database.HOST, user : config.database.USERNAME, password : config.database.PASSWORD, database : config.database.DATABASE&#125;);let query = function( sql, values ) &#123; return new Promise(( resolve, reject ) =&gt; &#123; pool.getConnection(function(err, connection) &#123; if (err) &#123; resolve( err ) &#125; else &#123; connection.query(sql, values, ( err, rows) =&gt; &#123; if ( err ) &#123; reject( err ) &#125; else &#123; resolve( rows ) &#125; connection.release() &#125;) &#125; &#125;) &#125;)&#125;users=`create table if not exists users( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, pass VARCHAR(40) NOT NULL, PRIMARY KEY ( id ));`posts=`create table if not exists posts( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, title VARCHAR(40) NOT NULL, content VARCHAR(40) NOT NULL, uid VARCHAR(40) NOT NULL, moment VARCHAR(40) NOT NULL, comments VARCHAR(40) NOT NULL DEFAULT &apos;0&apos;, pv VARCHAR(40) NOT NULL DEFAULT &apos;0&apos;, PRIMARY KEY ( id ));`comment=`create table if not exists comment( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, content VARCHAR(40) NOT NULL, postid VARCHAR(40) NOT NULL, PRIMARY KEY ( id ));`let createTable = function( sql ) &#123; return query( sql, [] )&#125;// 建表createTable(users)createTable(posts)createTable(comment)// 注册用户let insertData = function( value ) &#123; let _sql = &quot;insert into users(name,pass) values(?,?);&quot; return query( _sql, value )&#125;// 发表文章let insertPost = function( value ) &#123; let _sql = &quot;insert into posts(name,title,content,uid,moment) values(?,?,?,?,?);&quot; return query( _sql, value )&#125;// 更新文章评论数let updatePostComment = function( value ) &#123; let _sql = &quot;update posts set comments=? where id=?&quot; return query( _sql, value )&#125;// 更新浏览数let updatePostPv = function( value ) &#123; let _sql = &quot;update posts set pv=? where id=?&quot; return query( _sql, value )&#125;// 发表评论let insertComment = function( value ) &#123; let _sql = &quot;insert into comment(name,content,postid) values(?,?,?);&quot; return query( _sql, value )&#125;// 通过名字查找用户let findDataByName = function ( name ) &#123; let _sql = ` SELECT * from users where name=&quot;$&#123;name&#125;&quot; ` return query( _sql)&#125;// 通过文章的名字查找用户let findDataByUser = function ( name ) &#123; let _sql = ` SELECT * from posts where name=&quot;$&#123;name&#125;&quot; ` return query( _sql)&#125;// 通过文章id查找let findDataById = function ( id ) &#123; let _sql = ` SELECT * from posts where id=&quot;$&#123;id&#125;&quot; ` return query( _sql)&#125;// 通过评论id查找let findCommentById = function ( id ) &#123; let _sql = ` SELECT * FROM comment where postid=&quot;$&#123;id&#125;&quot; ` return query( _sql)&#125;// 查询所有文章let findAllPost = function ( ) &#123; let _sql = ` SELECT * FROM posts ` return query( _sql)&#125;// 更新修改文章let updatePost = function(values)&#123; let _sql=`update posts set title=?,content=? where id=?` return query(_sql,values)&#125;// 删除文章let deletePost = function(id)&#123; let _sql=`delete from posts where id = $&#123;id&#125;` return query(_sql)&#125;// 删除评论let deleteComment = function(id)&#123; let _sql=`delete from comment where id = $&#123;id&#125;` return query(_sql)&#125;// 删除所有评论let deleteAllPostComment = function(id)&#123; let _sql=`delete from comment where postid = $&#123;id&#125;` return query(_sql)&#125;// 查找let findCommentLength = function(id)&#123; let _sql=`select content from comment where postid in (select id from posts where id=$&#123;id&#125;)` return query(_sql)&#125;module.exports=&#123; query, createTable, insertData, findDataByName, insertPost, findAllPost, findDataByUser, findDataById, insertComment, findCommentById, updatePost, deletePost, deleteComment, findCommentLength, updatePostComment, deleteAllPostComment, updatePostPv&#125; 下面是我们建的表 users posts comment id id id name name name pass title content content postid uid moment comments pv id主键递增 name: 用户名 pass：密码 title：文章标题 content：文章内容和评论 uid：发表文章的用户id moment：创建时间 comments：文章评论数 pv：文章浏览数 postid：文章id 现在感觉有点枯燥，那我们先来实现一下注册吧 实现注册页面routers/singup.js 12345678910var router=require(&apos;koa-router&apos;)();// GET &apos;/signup&apos; 注册页router.get(&apos;/signup&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signup&apos;,&#123; &#125;)&#125;)module.exports=router 使用get方式得到’/signup’页面，然后渲染signup模板，这里我们还没有在写signup.ejs views/signup.ejs 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input class=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input class=&quot;repeatpass&quot; type=&quot;password&quot; name=&quot;repeatpass&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们先安装supervisor 1$ cnpm i supervisor supervisor的作用是会监听文件的变化，而我们修改文件之后不必去重启程序1supervisor --harmony index 现在访问 localhost:3000/signup 看看效果吧。注意数据库一定要是开启的状态，不能关闭 完善注册功能首先我们来完善一下样式吧，稍微美化一下 public/index.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173body,header,ul,li,p,div,html,span,h3,a&#123; margin: 0; padding: 0; color: #333;&#125;body&#123; margin-bottom: 20px;&#125;a&#123; text-decoration: none;&#125;header&#123; width: 60%; margin: 20px auto; display: -webkit-flex; display: -moz-flex; display: -ms-flex; display: -o-flex; display: flex; justify-content: space-between;&#125;.user_name&#123; font-size: 20px;&#125;.has_user&#123; &#125;.has_user a,.has_user span,.none_user a&#123; padding: 5px 15px; background: #5FB878; border-radius: 15px; color: #fff; cursor: pointer;&#125;.posts&#123; list-style: none; width: 60%; margin: 0 auto;&#125;.posts li&#123; margin-top: 10px; border: 1px solid #ccc; border-radius: 5px; position: relative; padding-bottom: 50px;&#125;h3&#123; display: inline-block; padding: 5px 10px; background: #1E9FFF; color: #fff; border-radius: 10px;&#125;.post_title p,.post_content p&#123; margin: 10px 0; background: #eee; padding: 10px 20px; border: 1px solid #ddd; border-radius: 4px;&#125;.post_time&#123; position: absolute; bottom: 5px; right: 10px;&#125;.post_3&#123; position: absolute; bottom: 5px; left: 10px;&#125;.post_3 p&#123; display: inline-block; margin-left: 5px;&#125;.post_title&#123; padding: 10px 20px;&#125;.post_content&#123; padding: 0 20px;&#125;.spost&#123; width: 60%; margin:0 auto; border: 1px solid #ddd; position: relative; padding-bottom: 40px;&#125;.spost_user&#123; position: absolute; left: 20px; bottom: 5px;&#125;.edit&#123; position: absolute; right: 20px; bottom: 5px;&#125;.edit p&#123; display: inline-block; margin-left: 10px; &#125;.comment_wrap&#123; width: 60%; margin:20px auto; &#125;.submit&#123; display: block; width: 90px; height: 35px; line-height: 35px; text-align: center; border-radius: 10px; background: #5FB878; cursor: pointer; color: #fff; float: right; margin-top: 20px;&#125;.cmt_content&#123; background: #eee; padding: 20px ; position: relative;&#125;.cmt_name&#123; position: absolute; right: 20px; bottom: 5px;&#125;.cmt_name a&#123; margin-left: 10px;&#125;.cmt_content&#123; margin-top: 10px;&#125;.form&#123; margin:0 auto; width: 50%; margin-top: 20px;&#125;textarea&#123; width: 100%; height: 200px; padding-left: 20px; font-size: 20px;&#125;.container&#123; width: 60%; margin: 0 auto;&#125;input&#123; display: block; width: 100%; height: 40px; padding-left: 20px; font-size: 20px;&#125;.create label&#123; display: block; margin: 10px 0;&#125;.comment_wrap form&#123; width: 100%;&#125;.delete_comment,.delete_post&#123; cursor: pointer;&#125;.delete_comment:hover,.delete_post:hover&#123; color: #f60;&#125;a:hover&#123; color: #f60;&#125; 我们再把模板引擎的header和footer独立出来 /views/header.ejs顺便引入index.css和jq123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;body&gt; /views/footer.ejs 123 &lt;/body&gt;&lt;/html&gt; 修改views/signup.ejs 12345678910111213141516171819&lt;% include header %&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input class=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input class=&quot;repeatpass&quot; type=&quot;password&quot; name=&quot;repeatpass&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;% include footer %&gt; 修改routers/signup.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var router=require(&apos;koa-router&apos;)();// 处理数据库（之前已经写好，在mysql.js）var userModel=require(&apos;../lib/mysql.js&apos;);// 加密var md5=require(&apos;md5&apos;)router.get(&apos;/signup&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signup&apos;,&#123; session:ctx.session, &#125;)&#125;)// POST &apos;/signup&apos; 注册页router.post(&apos;/signup&apos;,async (ctx,next)=&gt;&#123; console.log(ctx.request.body) var user=&#123; name:ctx.request.body.name, pass:ctx.request.body.password, repeatpass:ctx.request.body.repeatpass &#125; await userModel.findDataByName(user.name) .then(result=&gt;&#123; // var res=JSON.parse(JSON.stringify(reslut)) console.log(result) if (result.length)&#123; try &#123; throw Error(&apos;用户存在&apos;) &#125;catch (error)&#123; //处理err console.log(error) &#125; ctx.body=&#123; data:1 &#125;;; &#125;else if (user.pass!==user.repeatpass || user.pass==&apos;&apos;)&#123; ctx.body=&#123; data:2 &#125;; &#125;else&#123; ctx.body=&#123; data:3 &#125;; console.log(&apos;注册成功&apos;) // ctx.session.user=ctx.request.body.name userModel.insertData([ctx.request.body.name,md5(ctx.request.body.password)]) &#125; &#125;)&#125;)module.exports=router 我们使用md5实现密码加密 使用我们之前说的bodyParse来解析提交的数据，通过ctx.request.body得到 我们引入了数据库的操作 findDataByName和insertData，因为之前我们在/lib/mysql.js中已经把他们写好，并暴露出来了。意思是先从数据库里面查找注册的用户名，如果找到了证明该用户名已经被注册过了，如果没有找到则使用insertData增加到数据库中 ctx.body 是我们通过ajax提交之后给页面返回的数据，比如提交ajax成功之后msg.data=1的时候就代表用户存在，msg.data出现在后面的signup.ejs模板ajax请求中 我们使用ajax来提交数据，方便来做成功错误的处理 模板引擎ejs我们使用的是ejs，语法可以见ejs官网 之前我们写了这么一段代码12345router.get(&apos;/signup&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signup&apos;,&#123; session:ctx.session, &#125;)&#125;) 这里就用到了ejs所需的session 我们通过渲染signup.ejs模板，将值ctx.session赋值给session，之后我们就可以在signup.ejs中使用了ejs的常用标签为： &lt;% code %&gt;：运行 JavaScript 代码，不输出 &lt;%= code %&gt;：显示转义后的 HTML内容 &lt;%- code %&gt;：显示原始 HTML 内容 &lt;%= code %&gt;和&lt;%- code %&gt;的区别在于，&lt;%= code %&gt;不管你写什么都会原样输出，比如code为 &lt;strong&gt;hello&lt;/strong&gt;的时候 &lt;%= code %&gt; 会显示&lt;strong&gt;hello&lt;/strong&gt;而&lt;%- code %&gt;则显示加粗的hello 修改/views/signup.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;% include header %&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input class=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input class=&quot;repeatpass&quot; type=&quot;password&quot; name=&quot;repeatpass&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; $(&apos;.submit&apos;).click(()=&gt;&#123; console.log($(&apos;.form&apos;).serialize()) $.ajax(&#123; url: &quot;/signup&quot;, data: $(&apos;.form&apos;).serialize(), type: &quot;POST&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (msg.data == 1) &#123; $(&apos;.error&apos;).text(&apos;用户名存在&apos;) $(&apos;input&apos;).val(&apos;&apos;) fade(&apos;.error&apos;) &#125; else if (msg.data == 2)&#123; $(&apos;.error&apos;).text(&apos;请输入重复的密码&apos;) fade(&apos;.error&apos;) &#125; else if(msg.data == 3)&#123; $(&apos;.success&apos;).text(&apos;注册成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/signin&quot; &#125;,1000) &#125; //console.log($(&apos;.ui.error.message&apos;).text); &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;) &lt;/script&gt;&lt;% include footer %&gt; 这里重点就在于ajax提交了，提交之后换回数据 1 2 3，然后分别做正确错误处理，把信息写在error和success中 修改/views/header.ejs 我们之前在/routers/signup.js get ‘/signup’ 中 向模板传递了session参数 session:ctx.session,存取的就是用户的信息，包括用户名、登录之后的id等，之所以可以通过ctx.session获取到，因为我们在后面登录的时候已经赋值 如ctx.session.user=res[0][‘name’] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;koa-blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;header&gt; &lt;div class=&quot;user_name&quot;&gt; user： &lt;% if(session.user)&#123; %&gt; &lt;%= session.user %&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; 未登录 &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class=&quot;message&quot;&gt; &lt;div class=&quot;error&quot;&gt;&lt;/div&gt; &lt;div class=&quot;success&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;user_right&quot;&gt; &lt;% if(session.user)&#123; %&gt; &lt;div class=&quot;has_user&quot;&gt; &lt;a href=&quot;/posts&quot;&gt;全部文章&lt;/a&gt; &lt;a href=&quot;/create&quot;&gt;发表文章&lt;/a&gt; &lt;span class=&quot;signout&quot;&gt;登出&lt;/span&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; &lt;div class=&quot;none_user&quot;&gt; &lt;a href=&quot;/posts&quot;&gt;全部文章&lt;/a&gt; &lt;a href=&quot;/signup&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;/signin&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/header&gt; &lt;script&gt; function fade(data)&#123; if ($(data).css(&apos;display&apos;)!==&apos;none&apos;) &#123; $(data).fadeOut(1500) &#125; else&#123; $(data).show() $(data).fadeOut(1500) &#125; &#125; &lt;/script&gt; 我们可以看到，如果不存在用户，则只显示全部文章 注册 登录 ,如果session.user存在则有登出的按钮 我们可以看到当状态data为 3 的时候window.location.href=”/signin”为了方便跳转，我们先简单实现一下signin页面 修改 /routers/signin.js 123456789var router=require(&apos;koa-router&apos;)();// get &apos;/signin&apos;登录页面router.get(&apos;/signin&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signin&apos;,&#123; session:ctx.session, &#125;)&#125;)module.exports=router 修改 /views/signin.ejs 123456789101112131415&lt;% include header %&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post &quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder=&quot;密码&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;登录&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;% include footer %&gt; 修改 index.js 文件 把下面这段代码注释去掉，之前注释是因为我们没有写signin的路由，以免报错，后面还有文章页和登出页的路由，大家记住一下 1app.use(require(&apos;./routers/signin.js&apos;).routes()) 现在注册一下来看看效果吧1$ supervisor --harmony index 我们怎么查看我们注册好的账号和密码呢？打开mysql控制台 1$ select * from users; 这样刚刚我们注册的用户信息都出现了 如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wclimb/Koa2-blog 登录页面修改signinrouters/signin.js 1234567891011121314151617181920212223242526272829303132333435363738394041var router=require(&apos;koa-router&apos;)();// 处理数据库（之前已经写好，在mysql.js）var userModel=require(&apos;../lib/mysql.js&apos;)// 加密var md5=require(&apos;md5&apos;)// get &apos;/signin&apos;登录页面router.get(&apos;/signin&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;signin&apos;,&#123; session:ctx.session, &#125;)&#125;)// post &apos;/signin&apos;登录页面router.post(&apos;/signin&apos;,async (ctx,next)=&gt;&#123; console.log(ctx.request.body) var name=ctx.request.body.name; var pass=ctx.request.body.password; // 这里先查找用户名存在与否，存在则判断密码正确与否，不存在就返回false await userModel.findDataByName(name) .then(result =&gt;&#123; // console.log(reslut) var res=JSON.parse(JSON.stringify(result)) if (name === res[0][&apos;name&apos;] &amp;&amp; md5(pass) === res[0][&apos;pass&apos;]) &#123; ctx.body=&apos;true&apos; // ctx.flash.success=&apos;登录成功!&apos;; ctx.session.user=res[0][&apos;name&apos;] ctx.session.id=res[0][&apos;id&apos;] console.log(&apos;ctx.session.id&apos;,ctx.session.id) // ctx.redirect(&apos;/posts&apos;) console.log(&apos;session&apos;,ctx.session) console.log(&apos;登录成功&apos;) &#125; &#125;).catch(err=&gt;&#123; ctx.body=&apos;false&apos; console.log(&apos;用户名或密码错误!&apos;) // ctx.redirect(&apos;/signin&apos;) &#125;)&#125;)module.exports=router 我们进行登录操作，判断登录的用户名和密码是否有误，使用md5加密我们可以看到登录成功返回的结果是result 然后处理一下 var res=JSON.parse(JSON.stringify(result))为什么呢？因为返回的结果是这样的一个数组：id：4 name：rrr pass：…[ RowDataPacket { id: 4, name: ‘rrr’, pass: ‘44f437ced647ec3f40fa0841041871cd’ } ] 修改views/signin.ejssignin.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;% include header %&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post &quot;&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder=&quot;用户名&quot; type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder=&quot;密码&quot; type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;登录&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; $(&apos;.submit&apos;).click(()=&gt;&#123; console.log($(&apos;.form&apos;).serialize()) $.ajax(&#123; url: &quot;/signin&quot;, data: $(&apos;.form&apos;).serialize(), type: &quot;POST&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (!msg) &#123; $(&apos;.error&apos;).text(&apos;用户名或密码错误&apos;) $(&apos;input&apos;).val(&apos;&apos;) fade(&apos;.error&apos;) &#125; else&#123; $(&apos;.success&apos;).text(&apos;登录成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/posts&quot; &#125;,1000) &#125; //console.log($(&apos;.ui.error.message&apos;).text); &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;) &lt;/script&gt;&lt;% include footer %&gt; 我们增加了ajax请求，在routers/singin.js里，我们设置如果登录失败就返回false，登录成功返回true12ctx.body=&apos;false&apos;ctx.body=&apos;true&apos; 那我们登录成功后要做跳转，可以看到window.location.href=&quot;/posts&quot;跳转到posts页面 全部文章修改routers/posts.js posts.js 123456789101112131415161718var router=require(&apos;koa-router&apos;)();// 处理数据库（之前已经写好，在mysql.js）var userModel=require(&apos;../lib/mysql.js&apos;)// 时间中间件var moment=require(&apos;moment&apos;)// get &apos;/&apos;页面router.get(&apos;/&apos;,async (ctx,next)=&gt;&#123; ctx.redirect(&apos;/posts&apos;)&#125;)// get &apos;/posts&apos;页面router.get(&apos;/posts&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;posts&apos;,&#123; session:ctx.session &#125;) &#125;)module.exports=router 修改 index.js app.use(require(‘./routers/posts.js’).routes())的注释去掉 修改 views/posts.ejs 12345&lt;% include header %&gt; posts&lt;% include footer %&gt; 现在看看登录成功之后的页面吧 接下来我们事先登出页面 登出页面修改 router/signout.jssignout.js 12345678910var router=require(&apos;koa-router&apos;)();router.get(&apos;/signout&apos;,async (ctx,next)=&gt;&#123; ctx.session=null; console.log(&apos;登出成功&apos;) ctx.body=&apos;true&apos; &#125;)module.exports=router 把session设置为null即可 修改 index.js app.use(require(‘./routers/posts.js’).routes())的注释去掉，现在把注释的路由全部取消注释就对了 然后修改 views/header.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;koa-blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/index.css&quot;&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;header&gt; &lt;div class=&quot;user_name&quot;&gt; user： &lt;% if(session.user)&#123; %&gt; &lt;%= session.user %&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; 未登录 &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class=&quot;message&quot;&gt; &lt;div class=&quot;error&quot;&gt;&lt;/div&gt; &lt;div class=&quot;success&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;user_right&quot;&gt; &lt;% if(session.user)&#123; %&gt; &lt;div class=&quot;has_user&quot;&gt; &lt;a href=&quot;/posts&quot;&gt;全部文章&lt;/a&gt; &lt;a href=&quot;/create&quot;&gt;发表文章&lt;/a&gt; &lt;span class=&quot;signout&quot;&gt;登出&lt;/span&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; &lt;div class=&quot;none_user&quot;&gt; &lt;a href=&quot;/posts&quot;&gt;全部文章&lt;/a&gt; &lt;a href=&quot;/signup&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;/signin&quot;&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/header&gt; &lt;script&gt; function fade(data)&#123; if ($(data).css(&apos;display&apos;)!==&apos;none&apos;) &#123; $(data).fadeOut(1500) &#125; else&#123; $(data).show() $(data).fadeOut(1500) &#125; &#125; $(&apos;.signout&apos;).click(()=&gt;&#123; $.ajax(&#123; url: &quot;/signout&quot;, type: &quot;GET&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (msg) &#123; $(&apos;.success&apos;).text(&apos;登出成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/posts&quot; &#125;,1000) &#125; &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;) &lt;/script&gt; 增加点击登出后的ajax 的提交，成功之后回到posts页面 发表文章修改router/posts在后面增加12345678910111213141516171819202122232425// get &apos;/create&apos;router.get(&apos;/create&apos;,async (ctx,next)=&gt;&#123; await ctx.render(&apos;create&apos;,&#123; session:ctx.session, &#125;)&#125;)// psot &apos;/create&apos;router.post(&apos;/create&apos;,async (ctx,next)=&gt;&#123; console.log(ctx.session.user) var title=ctx.request.body.title var content=ctx.request.body.content var id=ctx.session.id var name=ctx.session.user var time=moment().format(&apos;YYYY-MM-DD HH:mm&apos;) console.log([name,title,content,id,time]) // 这里我们向数据库插入用户名、标题、内容、发表文章用户的id、时间，成功返回true，失败为false await userModel.insertPost([name,title,content,id,time]) .then(()=&gt;&#123; ctx.body=&apos;true&apos; &#125;).catch(()=&gt;&#123; ctx.body=&apos;false&apos; &#125;)&#125;) 修改 views/create.ejs create.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;% include header %&gt;&lt;div class=&quot;container&quot;&gt; &lt;form method=&quot;post&quot; class=&quot;form create&quot;&gt; &lt;div&gt; &lt;label&gt;标题：&lt;/label&gt; &lt;input placeholder=&quot;&quot; type=&quot;text&quot; name=&quot;title&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;内容：&lt;/label&gt; &lt;textarea name=&quot;content&quot; id=&quot;&quot; cols=&quot;42&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;submit&quot;&gt;发表&lt;/div&gt; &lt;/form&gt;&lt;/div&gt; &lt;script&gt; $(&apos;.submit&apos;).click(()=&gt;&#123; $.ajax(&#123; url: &quot;/create&quot;, data: $(&apos;.form&apos;).serialize(), type: &quot;POST&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (msg) &#123; $(&apos;.success&apos;).text(&apos;发表成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/posts&quot; &#125;,1000) &#125;else&#123; $(&apos;.success&apos;).text(&apos;发表失败&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.reload() &#125;,1000) &#125; &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;)&lt;/script&gt;&lt;% include footer %&gt; 现在看看能不能发表吧 即使我们发表了文章，但是当前我们的posts的页面没有显示，因为还没有获取到数据 接下来 修改 routers/posts.js 修改 get ‘/posts’ 12345678910111213141516171819202122232425262728router.get(&apos;/posts&apos;,async (ctx,next)=&gt;&#123; // 这里我们先通过查找有没有类似/posts?author=XXX 的连接跳转，如果有就执行下面这句话，把用户名取下来，由于用户名存在中文，所以我们进行解码 if (ctx.request.querystring) &#123; console.log(&apos;ctx.request.querystring&apos;,decodeURIComponent(ctx.request.querystring.split(&apos;=&apos;)[1])) await userModel.findDataByUser(decodeURIComponent(ctx.request.querystring.split(&apos;=&apos;)[1])) .then(result=&gt;&#123; res=JSON.parse(JSON.stringify(result)) console.log(res) &#125;) await ctx.render(&apos;posts&apos;,&#123; session:ctx.session, posts:res &#125;) &#125;else&#123; // 如果连接是正常的 如 /posts 则我们获取的是全部文章的列表，所以通过findAllPost查找全部文章并向模板传递数据posts， posts的值为res await userModel.findAllPost() .then(result=&gt;&#123; console.log(result) res=JSON.parse(JSON.stringify(result)) console.log(&apos;post&apos;,res) &#125;) await ctx.render(&apos;posts&apos;,&#123; session:ctx.session, posts:res &#125;) &#125;&#125;) if (ctx.request.querystring) {}这部分我们先不用管，后面会说。只需要看else后面的代码我们查找我们发表的全部文章然后将获取到的值定义为posts，传给模板posts.ejs，这样就可以渲染出来了 修改 Views/posts.ejs posts.ejs 123456789101112131415161718192021222324&lt;% include header %&gt; &lt;ul class=&quot;posts&quot;&gt; &lt;% posts.forEach(function(res)&#123; %&gt; &lt;li&gt; &lt;div class=&quot;post_3&quot;&gt; &lt;p class=&quot;post_user&quot;&gt;&lt;a href=&quot;/posts?author=&lt;%= res[&apos;name&apos;] %&gt;&quot;&gt;作者: &lt;%= res[&apos;name&apos;] %&gt;&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;post_comments&quot;&gt;评论数：&lt;%= res[&apos;comments&apos;] %&gt;&lt;/p&gt; &lt;p class=&quot;post_pv&quot;&gt;浏览数：&lt;%= res[&apos;pv&apos;] %&gt;&lt;/p&gt; &lt;/div&gt; &lt;a href=&quot;/posts/&lt;%= res[&apos;id&apos;] %&gt;&quot;&gt; &lt;div class=&quot;post_title&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;&lt;%= res[&apos;title&apos;] %&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;post_content&quot;&gt; &lt;h3&gt;content&lt;/h3&gt; &lt;p&gt;&lt;%= res[&apos;content&apos;] %&gt;&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;p class=&quot;post_time&quot;&gt;发表时间：&lt;%= res[&apos;moment&apos;] %&gt;&lt;/p&gt; &lt;/li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt;&lt;% include footer %&gt; 现在看看posts页面有没有文章出现了 我们看到是所有的文章，但是我需要点击单篇文章的时候，显示一篇文章怎么办呢？ 修改 routers/posts.js 在posts.js后面增加 1234567891011121314151617router.get(&apos;/posts/:postId&apos;,async (ctx,next)=&gt;&#123; console.log(ctx.params.postId) // 通过文章id查找返回数据，然后增加pv 浏览 +1 await userModel.findDataById(ctx.params.postId) .then(result=&gt;&#123; res=JSON.parse(JSON.stringify(result)) res_pv=parseInt(JSON.parse(JSON.stringify(result))[0][&apos;pv&apos;]) res_pv+=1 console.log(res) &#125;) // 渲染模板，并传递三个数据 await ctx.render(&apos;sPost&apos;,&#123; session:ctx.session, posts:res &#125;)&#125;) 现在的设计是，我们点进去出现的url是 /posts/1 这类的 1代表该篇文章的id，我们在数据库建表的时候就处理了，让id为主键，然后递增 我们通过userModel.findDataById 文章的id来查找数据库我们通过userModel.findCommentById 文章的id来查找文章的评论，因为单篇文章里面有评论的功能 单篇文章页修改 views/sPost.ejs sPost.ejs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;% include header %&gt; &lt;div class=&quot;spost&quot;&gt; &lt;p class=&quot;spost_user&quot;&gt;author: &lt;a href=&quot;/posts?author=&lt;%= posts[0][&apos;name&apos;] %&gt;&quot;&gt;&lt;%= posts[0][&apos;name&apos;] %&gt;&lt;/a&gt;&lt;/p&gt; &lt;div class=&quot;post_title&quot;&gt; &lt;h3&gt;title&lt;/h3&gt; &lt;p&gt;&lt;a href=&quot;/posts/&lt;%= posts[0][&apos;id&apos;] %&gt;&quot;&gt;&lt;%= posts[0][&apos;title&apos;] %&gt;&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;post_content&quot;&gt; &lt;h3&gt;content&lt;/h3&gt; &lt;p&gt;&lt;%= posts[0][&apos;content&apos;] %&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;edit&quot;&gt; &lt;% if(session &amp;&amp; session.user=== posts[0][&apos;name&apos;] )&#123; %&gt; &lt;p&gt;&lt;a href=&quot;&lt;%= posts[0][&apos;id&apos;] %&gt;/edit&quot;&gt;编辑&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a class=&quot;delete_post&quot; &gt;删除&lt;/a&gt;&lt;/p&gt; &lt;% &#125; %&gt; &lt;script&gt; $(&apos;.delete_post&apos;).click(()=&gt;&#123; $.ajax(&#123; url:&quot;&lt;%= posts[0][&apos;id&apos;] %&gt;/remove&quot;, type:&apos;GET&apos;, cache: false, success:function(msg)&#123; if (msg.data==1) &#123; $(&apos;.success&apos;).text(&apos;删除文章成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/posts&quot; &#125;,1000) &#125;else if(msg.data==2)&#123; $(&apos;.error&apos;).text(&apos;删除文章失败&apos;) fade(&apos;.error&apos;); setTimeout(()=&gt;&#123; window.location.reload() &#125;,1000) &#125; &#125; &#125;) &#125;) &lt;/script&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;comment_wrap&quot;&gt; &lt;h3&gt;comment&lt;/h3&gt; &lt;div class=&quot;comment_list&quot;&gt; &lt;% comments.forEach(function(res)&#123; %&gt; &lt;div class=&quot;cmt_lists&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;p class=&quot;cmt_content&quot;&gt; content: &lt;%= res[&apos;content&apos;] %&gt; &lt;span class=&quot;cmt_name&quot;&gt; By: &lt;%= res[&apos;name&apos;] %&gt; &lt;% if(session &amp;&amp; session.user === res[&apos;name&apos;] )&#123; %&gt; &lt;a class=&quot;delete_comment&quot;&gt; 删除&lt;/a&gt; &lt;% &#125; %&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; $(&apos;.delete_comment&apos;).click(()=&gt;&#123; $.ajax(&#123; url:&quot;&lt;%= posts[0][&apos;id&apos;] %&gt;/comment/&lt;%= res[&apos;id&apos;] %&gt;/remove&quot;, type:&apos;GET&apos;, cache: false, success:function(msg)&#123; if (msg.data==1) &#123; $(&apos;.success&apos;).text(&apos;删除留言成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.reload() &#125;,1000) &#125;else if(msg.data==2)&#123; $(&apos;.error&apos;).text(&apos;删除留言失败&apos;) fade(&apos;.error&apos;); setTimeout(()=&gt;&#123; window.location.reload() &#125;,1000) &#125; &#125;, error:function()&#123; alert(&apos;异常&apos;) &#125; &#125;) &#125;) &lt;/script&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;% if(session.user)&#123; %&gt; &lt;form class=&quot;form&quot; method=&quot;post&quot; action=&quot;/&lt;%= posts[0][&apos;id&apos;] %&gt;&quot;&gt; &lt;textarea name=&quot;content&quot; id=&quot;&quot;&gt;&lt;/textarea&gt; &lt;div class=&quot;submit&quot;&gt;发表留言&lt;/div&gt; &lt;/form&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;script&gt; $(&apos;.submit&apos;).click(function()&#123; $.ajax(&#123; url: &apos;/&apos;+document.URL.slice(document.URL.lastIndexOf(&apos;/&apos;)+1), data:$(&apos;.form&apos;).serialize(), type: &quot;POST&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (msg) &#123; $(&apos;.success&apos;).text(&apos;发表留言成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.reload() &#125;,1000) &#125; &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;) &lt;/script&gt; &lt;% include footer %&gt; 现在点击单篇文章试试，进入单篇文章页面，但是编辑、删除、评论都还没有做，点击无效，我们先不做，先实现每个用户发表的文章列表，我们之前在 get ‘/posts’ 里面说先忽略if (ctx.request.querystring) {}里面的代码，这里是做了应该处理，假如用户点击了某个用户，该用户发表了几篇文章，我们需要只显示该用户发表的文章，那么进入的url应该是 /posts?author=xxx ,这个处理在posts.ejs 就已经加上了，就在文章的左下角，作者：xxx就是一个链接。我们通过判断用户来查找文章，继而有了ctx.request.querystring 获取到的是：author=XXX 注：这里我们处理了，通过判断 session.user === res[&#39;name&#39;] 如果不是该用户发的文章，不能编辑和删除，评论也是。这里面也可以注意一下包裹的&lt;a href=&quot;&quot;&gt;&lt;/a&gt;标签 编辑文章、删除文章、评论、删除评论 评论 修改routers/posts.js 在post.js 后面增加 123456789101112131415161718192021router.post(&apos;/:postId&apos;,async (ctx,next)=&gt;&#123; var name=ctx.session.user var content=ctx.request.body.content var postId=ctx.params.postId // 插入评论的用户名，内容和文章id await userModel.insertComment([name,content,postId]) // 先通过文章id查找，然后评论数+1 await userModel.findDataById(postId) .then(result=&gt;&#123; res_comments=parseInt(JSON.parse(JSON.stringify(result))[0][&apos;comments&apos;]) res_comments+=1 &#125;) // 更新评论数 res_comments await userModel.updatePostComment([res_comments,postId]) .then(()=&gt;&#123; ctx.body=&apos;true&apos; &#125;).catch(()=&gt;&#123; ctx.body=&apos;false&apos; &#125;) &#125;) 现在试试发表评论的功能吧，之所以这样简单，因为我们之前就在sPost.ejs做了好几个ajax的处理，删除文章和评论也是如此 删除评论 修改routers/posts.js 继续在post.js 后面增加 1234567891011121314151617181920212223router.get(&apos;/posts/:postId/comment/:commentId/remove&apos;,async (ctx,next)=&gt;&#123; var postId=ctx.params.postId var commentId=ctx.params.commentId await userModel.findDataById(postId) .then(result=&gt;&#123; res_comments=parseInt(JSON.parse(JSON.stringify(result))[0][&apos;comments&apos;]) console.log(&apos;res&apos;,res_comments) res_comments-=1 console.log(res_comments) &#125;) await userModel.updatePostComment([res_comments,postId]) await userModel.deleteComment(commentId) .then(()=&gt;&#123; ctx.body=&#123; data:1 &#125; &#125;).catch(()=&gt;&#123; ctx.body=&#123; data:2 &#125; &#125;)&#125;) 现在试试删除评论的功能吧 删除文章 只有自己发表的文字删除的文字才会显示出来，才能被删除， 修改routers/posts.js 继续在post.js 后面增加 1234567891011121314151617router.get(&apos;/posts/:postId/remove&apos;,async (ctx,next)=&gt;&#123; var postId=ctx.params.postId await userModel.deleteAllPostComment(postId) await userModel.deletePost(postId) .then(()=&gt;&#123; ctx.body=&#123; data:1 &#125; &#125;).catch(()=&gt;&#123; ctx.body=&#123; data:2 &#125; &#125;) &#125;) 现在试试删除文章的功能吧 编辑文字 修改routers/posts.js 继续在post.js 后面增加 1234567891011121314151617181920212223242526272829// get &apos;/posts/:postId/edit&apos;router.get(&apos;/posts/:postId/edit&apos;,async (ctx,next)=&gt;&#123; var name=ctx.session.user var postId=ctx.params.postId await userModel.findDataById(postId) .then(result=&gt;&#123; res=JSON.parse(JSON.stringify(result)) console.log(&apos;修改文章&apos;,res) &#125;) await ctx.render(&apos;edit&apos;,&#123; session:ctx.session, posts:res &#125;)&#125;)// post &apos;/posts/:postId/edit&apos;router.post(&apos;/posts/:postId/edit&apos;,async (ctx,next)=&gt;&#123; var title=ctx.request.body.title var content=ctx.request.body.content var id=ctx.session.id var postId=ctx.params.postId await userModel.updatePost([title,content,postId]) .then(()=&gt;&#123; ctx.body=&apos;true&apos; &#125;).catch(()=&gt;&#123; ctx.body=&apos;false&apos; &#125;)&#125;) 修改views/edit.js 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;% include header %&gt;&lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form create&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;label&gt;标题：&lt;/label&gt; &lt;input placeholder=&quot;标题&quot; type=&quot;text&quot; name=&quot;title&quot; value=&quot;&lt;%= posts[0][&apos;title&apos;] %&gt;&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;内容：&lt;/label&gt; &lt;textarea name=&quot;content&quot; id=&quot;&quot; cols=&quot;42&quot; rows=&quot;10&quot;&gt; &lt;%= posts[0][&apos;content&apos;] %&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;!-- &lt;input type=&quot;submit&quot; value=&quot;修改&quot;&gt; --&gt; &lt;div class=&quot;submit&quot;&gt;修改&lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt; $(&apos;.submit&apos;).click(()=&gt;&#123; $.ajax(&#123; url: document.URL, data: $(&apos;.form&apos;).serialize(), type: &quot;POST&quot;, cache: false, dataType: &apos;json&apos;, success: function (msg) &#123; if (msg) &#123; $(&apos;.success&apos;).text(&apos;修改成功&apos;) fade(&apos;.success&apos;) setTimeout(()=&gt;&#123; window.location.href=&quot;/posts&quot; &#125;,1000) &#125; &#125;, error: function () &#123; alert(&apos;异常&apos;); &#125; &#125;) &#125;)&lt;/script&gt;&lt;% include footer %&gt; 现在试试编辑文字然后修改提交吧 结语至此一个简单的blog就已经制作好了，其他扩展功能相信你已经会了吧！如果出现问题，还望积极提问哈，我会尽快处理的 所有的代码都在 https://github.com/wclimb/Koa2-blog 里面，如果觉得不错就star一下吧。有问题可以提问哟下一篇可能是 Node + express + mongoose 或 zepto源码系列感谢您的阅读^_^]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Node</tag>
        <tag>Koa</tag>
        <tag>Mysql</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库（一）]]></title>
    <url>%2F2017%2F06%2F29%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面 读zepto源码，封装自己的zepto库系列是自己在读zepto源码的一些理解，有错误的地方还望指出。如果觉得本系列对你有所帮助，还请持续关注wclimb，谢谢。 zepto的整体架构首先来看看整体代码结构 123456789101112131415161718192021222324252627282930313233(function()&#123; var wclimb = &#123;&#125;,$ $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom; dom = document.querySelectorAll(selector); return wclimb.Z(dom,selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; wclimb.Z.prototype = Z.prototype = &#123; test:function()&#123; alert(1) &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wclimb = $&#125;)() 首先我们设置了一个闭包，避免产生全局变量123(function()&#123; ...&#125;)() 我们定义一个对象wclimb和$，以便后面使用 1var wclimb = &#123;&#125;,$ $函数返回了wclimb.init(selector),我们知道使用zepto的时候，一般是$(‘p’)，而selector就是p元素，当然不止这一种情况如$(function(){}),所以对选择器后面我们要做判断123$ = function(selector)&#123; return wclimb.init(selector)&#125; 而wclimb.init首先定义了一个dom，通过选择器选取的元素赋值给dom，最后返回wclimb.init，传入dom和选择元素selector 12345wclimb.init = function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector)&#125; 我们可以看到之前我们定义了对象wclimb，而后我们就往里面添加了一些方法，就像： 12345678910wclimb = &#123; init：function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector) &#125;, Z: function(dom,selector)&#123; return new Z(dom,selector) &#125;&#125; 通过wclimb.Z，如果有看过zepto源码的同学应该对此有了解.每次用$调用的时候,将直接返回一个Z的实例.达到无new调用的效果,$(‘p’)返回一个实例，然后$(‘p’).test()调用他的原形方法，这里的方法是test 1234567891011wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector)&#125;function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 由于我们是return new Z(dom,selector),那自然,我们需要手动的把wclimb.Z的prototype指向Z的prototype 123456789wclimb.Z.prototype = Z.prototype&#123;&#125;我们可以在里面添加方法了，如addClass eq等，我们试试加一个testwclimb.Z.prototype = Z.prototype&#123; test: function()&#123; console.log(&apos;test&apos;) &#125;&#125; Z函数是这样的，因为我们选择器选择的元素是一个数组（其实不是）我们把this指向选择的元素，然后添加两个元素selector和length，分别代表选择的元素名和元素的长度 1234567function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 最后我们在window上对外暴露一个接口,我们就可以用 $(‘p’) 或者wclimb(‘p’) 即可调用. 1window.$ = window.wclimb = $ 现在可以试试能不能运行 123html：&lt;p&gt;test&lt;/p&gt;js：$(&apos;p&apos;) 调用方法试试 $(&apos;p&apos;).test() 我们的zepto已经完成了，是不是很简单？骗你的，还差得远呢，后面会慢慢完善。待续。。。如果你觉得该文章帮助到了你，不妨star一下https://github.com/wclimb/wclimb.github.io ，感谢]]></content>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2017%2F06%2F28%2Fcanvas%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E7%85%A7%E7%89%87%2F</url>
    <content type="text"><![CDATA[canvas仿微信红包照片 By wclimbHTML1&lt;canvas id=&quot;cav&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt; CSS 设置canvas的背景图 1234canvas&#123; background:url(https://b-ssl.duitang.com/uploads/item/201501/22/20150122203239_Cfr58.thumb.700_0.jpeg) no-repeat; background-size:100% 100%;&#125; JS12345678910111213141516171819202122232425262728293031323334353637var canvas = document.querySelector(&quot;#cav&quot;)var context = canvas.getContext(&quot;2d&quot;);var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30)context.globalAlpha = 0.96;context.fillStyle = &apos;#333&apos;context.rect(0,0,canvas.width,canvas.height);context.fill();context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore();var num = 30;var time = null;document.body.onclick = function()&#123; function circle()&#123; num += 5 context.save() context.beginPath() context.arc(randomX,randomY,num,0,Math.PI*2,false); context.clip(); context.clearRect(0,0,canvas.width,canvas.height) context.restore(); console.log(num) if (num &gt;= 677)&#123; clearInterval(timer) &#125; &#125; timer = setInterval(circle,10)&#125; 解析 随机出现圆心的位置，因为canvas为500*500 圆心为30 所以圆心的范围为 X(30,470) Y(470,30) 12var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30) 绘制矩形 透明度为0.96 填充颜色#333 宽高为canvas的宽高 最后用fill填充 1234context.globalAlpha = 0.96;context.fillStyle = &apos;#333&apos;context.rect(0,0,canvas.width,canvas.height);context.fill(); 初始化圆心的位置，用arc绘制圆，默认半径为30，用clip剪切，只有被剪切区域内是可见的 123456context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore(); 点击body的时候，设置定时器，让圆的半径每隔10毫秒增加5，当num半径大于677关闭定时器，677为canvas对角的长度 1document.body.onclick = function()&#123;&#125; 效果预览]]></content>
      <categories>
        <category>javascript</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp基础教程]]></title>
    <url>%2F2017%2F06%2F27%2Fgulp%2F</url>
    <content type="text"><![CDATA[入门指南–引用gulp官网示例 全局安装 gulp： 1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： 1$ npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 12345var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp： 1$ gulp //默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。 至此，一个简单的gulp已经完成，接下来让我们来完善部分功能 gulp功能完善生成package.json文件1$ npm init //一直回车，有需要的可以设置 安装所需包 使用淘宝镜像 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org示例 $ cnpm install [name] 接着1$ cnpm i browser-sync gulp gulp-clean-css gulp-imagemin gulp-rename gulp-sass gulp-uglify gulp.spritesmith gulp-autoprefixer --save 新建gulpfile.js文件添加123456789var gulp = require(&apos;gulp&apos;); var browserSync = require(&apos;browser-sync&apos;).create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require(&apos;gulp-sass&apos;); //sass转cssvar reload = browserSync.reload; var minifyCSS = require(&apos;gulp-clean-css&apos;) //css压缩var uglify = require(&apos;gulp-uglify&apos;) //js压缩var imagemin = require(&apos;gulp-imagemin&apos;) //图片压缩var rename = require(&apos;gulp-rename&apos;) //文件重命名var autoprefixer = require(&apos;gulp-autoprefixer&apos;) //自动添加前缀 设置默认文件地址12345678code为文件夹，里面存放html css js文件var src = &#123; scss: &apos;code/scss/*.scss&apos;, css: &apos;code/css/*.css&apos;, html: &apos;code/*.html&apos;, js: &apos;code/js/*.js&apos;, images: &apos;code/images/*.&#123;png,jpg,gif,ico&#125;&apos;&#125;; gulp.task(name[, deps], fn)123456789101112131415161718name: 任务的名字deps: 一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。fn: 该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。// 静态服务器 + 监听 scss/html 文件 gulp.task(&apos;serve&apos;, [&apos;sass&apos;], function() &#123; browserSync.init(&#123; server: &quot;./code&quot; &#125;); gulp.watch(src.scss, [&apos;sass&apos;]); gulp.watch(src.css, [&apos;css&apos;]); gulp.watch(src.images, [&apos;images&apos;]) gulp.watch(src.js, [&apos;js-watch&apos;]); gulp.watch(src.js, [&apos;js&apos;]); gulp.watch(src.html).on(&apos;change&apos;, reload);&#125;); scss编译后的css将注入到浏览器里实现更新123456789101112131415gulp.task(&apos;sass&apos;, function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;,//保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 雪碧图（有需要可以尝试）123456789101112var spritesmith = require(&apos;gulp.spritesmith&apos;); gulp.task(&apos;sprite&apos;, function () &#123; return gulp.src(&apos;code/images/*.png&apos;) .pipe(spritesmith(&#123; imgName:&apos;images/sprite20161010.png&apos;, //保存合并后图片的地址 cssName:&apos;css/sprite.css&apos;, //保存合并后对于css样式的地址 padding:20, algorithm:&apos;binary-tree&apos;, &#125;)) .pipe(gulp.dest(&apos;code/scss&apos;)); &#125;); 监听css文件1234567gulp.task(&apos;css&apos;, function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 监听js文件12345678910111213gulp.task(&apos;js&apos;, function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest(&apos;code/dest&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;)//监听js文件变化实现热加载gulp.task(&apos;js-watch&apos;, [&apos;js&apos;], browserSync.reload); 压缩图片任务12345678910// 在命令行输入 gulp images 启动此任务gulp.task(&apos;images&apos;, function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest(&apos;images&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;); 最后控制台输入gulp执行1gulp.task(&apos;default&apos;, [&apos;serve&apos;]); 如果觉得帮助到了你，欢迎star -&gt; https://github.com/wclimb/wclimb.github.io 完整代码文件目录123456789101112-code -imgage 1.png -css default.css -scss default.scss -js default.js index.htmlgulpfile.jspackage.json packjson.js12345678910111213141516171819202122232425&#123; &quot;name&quot;: &quot;gulp-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Gulp &amp; SASS&quot;, &quot;main&quot;: &quot;gulpfile.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;gulp&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;browser-sync&quot;: &quot;^2.2.0&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-clean-css&quot;: &quot;^3.0.3&quot;, &quot;gulp-imagemin&quot;: &quot;^3.1.1&quot;, &quot;gulp-rename&quot;: &quot;^1.2.2&quot;, &quot;gulp-sass&quot;: &quot;^3.1.0&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.1&quot;, &quot;gulp.spritesmith&quot;: &quot;^6.4.0&quot;, &quot;gulp-autoprefixer&quot;: &quot;^4.0.0&quot; &#125;, &quot;dependencies&quot;: &#123; &#125;&#125; gulpfile.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106var gulp = require(&apos;gulp&apos;); var browserSync = require(&apos;browser-sync&apos;).create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require(&apos;gulp-sass&apos;); //sass转cssvar reload = browserSync.reload; var minifyCSS = require(&apos;gulp-clean-css&apos;) //css压缩var uglify = require(&apos;gulp-uglify&apos;) //js压缩var imagemin = require(&apos;gulp-imagemin&apos;) //图片压缩var rename = require(&apos;gulp-rename&apos;) //文件重命名var autoprefixer = require(&apos;gulp-autoprefixer&apos;) //自动添加前缀var src = &#123; scss: &apos;code/scss/*.scss&apos;, css: &apos;code/css/*.css&apos;, html: &apos;code/*.html&apos;, js: &apos;code/js/*.js&apos;, images: &apos;code/images/*.&#123;png,jpg,gif,ico&#125;&apos;&#125;;// 静态服务器 + 监听 scss/html 文件 gulp.task(&apos;serve&apos;, [&apos;sass&apos;], function() &#123; browserSync.init(&#123; server: &quot;./code&quot; &#125;); gulp.watch(src.scss, [&apos;sass&apos;]); gulp.watch(src.css, [&apos;css&apos;]); gulp.watch(src.images, [&apos;images&apos;]) gulp.watch(src.js, [&apos;js-watch&apos;]); gulp.watch(src.js, [&apos;js&apos;]); gulp.watch(src.html).on(&apos;change&apos;, reload);&#125;);// scss编译后的css将注入到浏览器里实现更新gulp.task(&apos;sass&apos;, function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;,//保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) //重新输出数据到某个文件夹，如果没有就会自动创建 .pipe(reload(&#123;stream: true&#125;));&#125;);// 雪碧图（有需要可以尝试）//var spritesmith = require(&apos;gulp.spritesmith&apos;); // gulp.task(&apos;sprite&apos;, function () &#123;// return gulp.src(&apos;code/images/*.png&apos;)// .pipe(spritesmith(&#123;// imgName:&apos;images/sprite20161010.png&apos;, //保存合并后图片的地址// cssName:&apos;css/sprite.css&apos;, //保存合并后对于css样式的地址// padding:20,// algorithm:&apos;binary-tree&apos;,// &#125;))// .pipe(gulp.dest(&apos;code/scss&apos;));// &#125;);gulp.task(&apos;css&apos;, function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) .pipe(gulp.dest(&quot;code/css&quot;)) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task(&apos;js&apos;, function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: &apos;.min&apos;&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest(&apos;code/dest&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;)//监听js文件变化实现热加载gulp.task(&apos;js-watch&apos;, [&apos;js&apos;], browserSync.reload);// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task(&apos;images&apos;, function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest(&apos;images&apos;)) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task(&apos;default&apos;, [&apos;serve&apos;]);]]></content>
      <categories>
        <category>javascript</category>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
</search>